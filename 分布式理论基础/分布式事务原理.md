## **一、分布式事务的背景**

### **🔍 为什么需要分布式事务？**

因为**一个业务操作会涉及多个服务/数据库/消息系统**，而传统的本地事务（如 MySQL 的事务）无法跨数据源生效：

例如：

下单 → 扣库存 → 扣余额 → 写订单表，这三个操作分布在三个微服务中，**如何保证这三个操作“要么全部成功，要么全部失败”？**



## **二、四种主流分布式事务方案一览**

| **模型**                       | **一致性** | **复杂度** | **延迟** | **特点**           |
| ------------------------------ | ---------- | ---------- | -------- | ------------------ |
| **2PC（两阶段提交）**          | 强一致性   | 高         | 高       | 同步、阻塞、经典   |
| **TCC（Try-Confirm-Cancel）**  | 强一致性   | 较高       | 中等     | 业务侵入，资源预留 |
| **SAGA（长事务拆分）**         | 最终一致   | 中等       | 低       | 反向操作补偿       |
| **异步可靠消息（最终一致性）** | 最终一致   | 中         | 低       | 解耦，异步处理     |



## **三、2PC：两阶段提交协议**



### **原理**

两阶段提交是一种协调者 + 参与者模型：



**阶段一：准备阶段（prepare）**

- 协调者向所有参与者发送 prepare 请求
- 各参与者执行本地事务并写入**undo log**，然后**锁定资源但不提交**
- 所有参与者返回“可以提交”或“失败”



**阶段二：提交阶段（commit）**

- 如果全部准备成功，协调者发出 commit，各节点提交事务
- 若任何参与者失败，协调者发出 rollback，所有节点回滚事务



### **优点**

- 一致性强
- 不依赖业务逻辑，透明



### **缺点**

- 同步阻塞，参与者长时间占有资源
- 协调者单点故障风险（容易脑裂）
- 准备完成后无法自动恢复（例如协调者挂了）



### **场景**

- 银行内部资金转账
- 用于强一致场景（但在分布式系统中较少采用）



## **四、TCC：Try-Confirm-Cancel 模型**



### **原理**

- 将一个操作拆分为三个阶段：

  - **Try：预留资源**（如冻结余额、预减库存）
  - **Confirm：确认提交**（真正扣款、减库存）
  - **Cancel：取消操作**（解冻、回滚）
  



### **特点**

- 所有资源在 Try 阶段被**预占或锁定**
- Confirm 和 Cancel 要具备**幂等性**、**空回滚保护**



### **优点**

- 执行快（异步）
- 明确的资源预留机制
- 容易恢复与补偿



### **缺点**

- 对业务侵入性强，要显式写三个方法
- 实现复杂，对幂等和异常恢复要求高



### **场景**

- 电商下单场景（库存、余额冻结）
- 酒店/机票/车票等**资源锁定**类场景





## **五、SAGA：长事务补偿模型**



### **原理**

将一个大事务拆分为多个**本地事务 + 补偿操作（反向操作）**，按顺序执行：

```
T1 → T2 → T3 ...
如果 T2 执行失败，则按反方向执行 C1（补偿 T1）
```

| **组件**   | **作用**                                 |
| ---------- | ---------------------------------------- |
| T1、T2、T3 | 正向操作（如创建订单、扣库存、扣余额）   |
| C1、C2、C3 | 补偿操作（如取消订单、回滚库存、退余额） |



### **优点**

- 异步非阻塞，系统可用性高
- 无全局锁、无资源长时间占用
- 对业务侵入比 TCC 小



### **缺点**

- 仅保证最终一致性（有延迟）
- 对业务补偿逻辑要求高
- 难以处理跨服务间复杂失败场景



### **场景**

- 电商交易流程（订单 → 库存 → 支付）
- 微服务场景下较常用的一致性策略



## **六、异步消息 + 本地事务（可靠消息最终一致性）**



### **原理**

利用 MQ 保证多个系统之间数据最终一致：

1. 本地事务执行成功后，将消息写入**本地消息表**（或消息中间件）
2. 成功提交本地事务后，将消息异步推送到 MQ
3. 消费方消费并执行对应逻辑，失败时重试、幂等处理



### **优点**

- 解耦、性能高
- 不阻塞，保证最终一致



### **缺点**

- 实现麻烦（本地消息表/事务消息）
- 补偿机制复杂
- 不适用于强一致性场景



### **场景**

- 订单系统异步发短信/发邮件
- 订单写 DB → 发 MQ 同步 ES



## **七、方案选择建议**

| **需求**                   | **推荐方案**          |
| -------------------------- | --------------------- |
| 强一致、同步写多个系统     | 2PC、TCC              |
| 能容忍短暂不一致、性能优先 | SAGA、MQ 最终一致性   |
| 多步骤业务、长时间操作     | SAGA                  |
| 存在资源冻结/锁定          | TCC                   |
| 跨 DB 操作，不方便协调事务 | MQ + 本地事务 或 SAGA |



## **八、常见面试问法**

1. 分布式事务有哪些解决方案？它们的区别是什么？
2. 你项目中是否用过 TCC 或 SAGA？怎么设计的？
3. TCC 模型中幂等如何保证？空回滚如何处理？
4. MQ 场景下怎么保证不丢消息？如何处理幂等性？
5. 为什么说 2PC 存在协调者单点问题？怎么优化？
