下面给你一个**工程里常用、可落地**的“订单状态机”示例（Java 17+）。特点：



- **表驱动**（用转移表定义状态→事件→下个状态），避免 if/else 树；
- **Guard + Action**（条件校验与副作用分离）；
- **幂等**（基于事件去重）；
- **乐观锁**（基于 version 字段防并发乱序）；
- **Outbox**（在事务内写出站事件，供 MQ 异步投递）。



你可以把它当成一个最小可用的骨架，直接嵌到 Spring 项目里（把 Repository 换成你的 DAO）。我把核心都放在同一文件里，便于拷贝试跑。

```java
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;

/** ===== 1) 领域模型 ===== */
enum OrderState {
    CREATED,        // 已创建（待支付）
    PAID,           // 已支付（待履约）
    FULFILLING,     // 履约中（打包/发货等）
    COMPLETED,      // 完成
    CANCELED,       // 取消
    REFUNDING,      // 退款中
    REFUNDED        // 已退款
}

enum OrderEvent {
    PAY,            // 支付成功
    START_FULFILL,  // 开始履约
    DELIVERED,      // 送达/签收
    CANCEL,         // 客服/用户取消（允许部分节点）
    REQUEST_REFUND, // 申请退款
    REFUND_SUCCESS  // 退款完成
}

/** 幂等事件：每个外部输入都带 eventId，避免重复消费 */
record IncomingEvent(String eventId, OrderEvent type, Map<String, Object> payload) {}

class Order {
    final String id;
    OrderState state;
    long version;            // 乐观锁版本
    Instant updatedAt;
    // 业务字段略
    Order(String id, OrderState state) {
        this.id = id;
        this.state = state;
        this.version = 0;
        this.updatedAt = Instant.now();
    }
}

/** ===== 2) 基础设施（简化的仓储 & Outbox） ===== */
interface OrderRepository {
    Optional<Order> findById(String id);
    /** 带版本检查的更新（UPDATE ... WHERE id=? AND version=?） */
    boolean updateWithVersion(Order o, OrderState newState, long expectVersion);
    /** 幂等事件去重表（eventId 已处理过就返回 true） */
    boolean markEventProcessedOnce(String orderId, String eventId);
    /** 事务模板（把下面三步放到一个事务里）：读→校验/转移→写订单+写outbox+写幂等表 */
    <T> T inTransaction(SupplierWithException<T> logic) throws Exception;
    void saveOutbox(String topic, String key, String json);
}

@FunctionalInterface interface SupplierWithException<T> { T get() throws Exception; }

/** 一个内存实现，方便你本地跑通；生产上换成 DB/MQ */
class InMemoryRepo implements OrderRepository {
    final Map<String, Order> store = new ConcurrentHashMap<>();
    final Map<String, Set<String>> processed = new ConcurrentHashMap<>();
    final List<String> outbox = Collections.synchronizedList(new ArrayList<>());
    @Override public Optional<Order> findById(String id){ return Optional.ofNullable(store.get(id)); }
    @Override public boolean updateWithVersion(Order o, OrderState ns, long ev){
        if (o.version != ev) return false;
        o.state = ns; o.version++; o.updatedAt = Instant.now(); return true;
    }
    @Override public boolean markEventProcessedOnce(String oid, String eid){
        processed.putIfAbsent(oid, ConcurrentHashMap.newKeySet());
        return processed.get(oid).add(eid); // 第一次返回 true
    }
    @Override public <T> T inTransaction(SupplierWithException<T> logic) throws Exception { return logic.get(); }
    @Override public void saveOutbox(String topic, String key, String json){ outbox.add(topic+":"+key+":"+json); }
}

/** ===== 3) 状态机定义：Guard + Action + Transition ===== */
record Transition(
        OrderState from,
        OrderEvent on,
        OrderState to,
        BiPredicate<Order, IncomingEvent> guard,  // 是否允许转移
        BiConsumer<Order, IncomingEvent> action   // 副作用（写日志/写outbox/改字段）
) {}

class StateMachine {
    private final Map<OrderState, Map<OrderEvent, Transition>> table = new EnumMap<>(OrderState.class);
    StateMachine(List<Transition> transitions) {
        for (var t : transitions) {
            table.computeIfAbsent(t.from(), k -> new EnumMap<>(OrderEvent.class))
                 .put(t.on(), t);
        }
    }
    Optional<Transition> find(OrderState s, OrderEvent e) {
        return Optional.ofNullable(table.getOrDefault(s, Map.of()).get(e));
    }
}

/** ===== 4) 应用服务：封装 幂等 + 读写一致性 + 执行状态机 ===== */
class OrderStateService {
    private final OrderRepository repo;
    private final StateMachine sm;
    OrderStateService(OrderRepository repo, StateMachine sm) {
        this.repo = repo; this.sm = sm;
    }

    /** 核心入口：对订单施加一个事件（带幂等 eventId） */
    public Order applyEvent(String orderId, IncomingEvent evt) throws Exception {
        return repo.inTransaction(() -> {
            var order = repo.findById(orderId).orElseThrow(() -> new NoSuchElementException("order not found"));
            // 1) 幂等：同一个 eventId 只处理一次
            if (!repo.markEventProcessedOnce(orderId, evt.eventId())) {
                return order; // 已处理过，直接返回
            }
            var transOpt = sm.find(order.state, evt.type());
            if (transOpt.isEmpty()) {
                throw new IllegalStateException("Invalid transition: " + order.state + " --" + evt.type() + "--/> ?");
            }
            var t = transOpt.get();
            // 2) Guard
            if (!t.guard().test(order, evt)) {
                throw new IllegalStateException("Guard rejected: " + order.state + " --" + evt.type());
            }
            var from = order.state;
            var expectVersion = order.version;
            // 3) Action（副作用在内存里先执行：可填充出站消息体等）
            t.action().accept(order, evt);
            // 4) 持久化状态转移（乐观锁）
            boolean ok = repo.updateWithVersion(order, t.to(), expectVersion);
            if (!ok) throw new ConcurrentModificationException("Order version changed, retry");
            // 5) Outbox 写在同事务里（示例）
            repo.saveOutbox("order-events", order.id, "{\"from\":\""+from+"\",\"to\":\""+t.to()+"\",\"event\":\""+evt.type()+"\"}");
            return order;
        });
    }
}

/** ===== 5) 组装：定义转移表（像配置一样维护） ===== */
class OrderStateMachineFactory {

    static StateMachine build() {
        List<Transition> list = new ArrayList<>();

        // CREATED --PAY--> PAID
        list.add(new Transition(
                OrderState.CREATED, OrderEvent.PAY, OrderState.PAID,
                (o, e) -> true, // 示例：可加金额校验、支付单状态查询等
                (o, e) -> {/* 填充支付时间、支付流水号等 */ }
        ));

        // PAID --START_FULFILL--> FULFILLING
        list.add(new Transition(
                OrderState.PAID, OrderEvent.START_FULFILL, OrderState.FULFILLING,
                (o, e) -> true,
                (o, e) -> {/* 分配仓库/波次，预占库存已完成等 */}
        ));

        // FULFILLING --DELIVERED--> COMPLETED
        list.add(new Transition(
                OrderState.FULFILLING, OrderEvent.DELIVERED, OrderState.COMPLETED,
                (o, e) -> true,
                (o, e) -> {/* 结算积分、触发好评引导等 */}
        ));

        // CREATED/PAID 允许 CANCEL（风控/超时）
        list.add(new Transition(
                OrderState.CREATED, OrderEvent.CANCEL, OrderState.CANCELED,
                (o, e) -> true,
                (o, e) -> {/* 释放库存、关闭支付单 */}
        ));
        list.add(new Transition(
                OrderState.PAID, OrderEvent.CANCEL, OrderState.REFUNDING,
                (o, e) -> true,
                (o, e) -> {/* 创建退款单，走退款流程 */}
        ));

        // PAID/COMPLETED 支持用户申请退款
        list.add(new Transition(
                OrderState.PAID, OrderEvent.REQUEST_REFUND, OrderState.REFUNDING,
                (o, e) -> true,
                (o, e) -> {/* 校验可退规则，落退款单 */}
        ));
        list.add(new Transition(
                OrderState.COMPLETED, OrderEvent.REQUEST_REFUND, OrderState.REFUNDING,
                (o, e) -> within7DaysOf(o.updatedAt), // 示例：完成7天内可退
                (o, e) -> {/* 走售后退款通道 */}
        ));

        // REFUNDING --REFUND_SUCCESS--> REFUNDED
        list.add(new Transition(
                OrderState.REFUNDING, OrderEvent.REFUND_SUCCESS, OrderState.REFUNDED,
                (o, e) -> true,
                (o, e) -> {/* 反结算、回退优惠券状态等 */}
        ));

        // 从 FULFILLING 直接取消通常不允许（已发货），不配置即非法

        return new StateMachine(list);
    }

    private static boolean within7DaysOf(Instant ts) {
        return ts != null && ts.isAfter(Instant.now().minusSeconds(7*24*3600));
    }
}

/** ===== 6) Demo：如何使用（把它改成你的单元测试就行） ===== */
public class OrderStateMachineDemo {
    public static void main(String[] args) throws Exception {
        var repo = new InMemoryRepo();
        var sm = OrderStateMachineFactory.build();
        var svc = new OrderStateService(repo, sm);

        var order = new Order("o1", OrderState.CREATED);
        repo.store.put(order.id, order);

        // 1) 支付
        svc.applyEvent(order.id, new IncomingEvent("evt-1", OrderEvent.PAY, Map.of("amount", 100)));
        // 2) 幂等重放（相同 eventId 不会重复生效）
        svc.applyEvent(order.id, new IncomingEvent("evt-1", OrderEvent.PAY, Map.of()));
        // 3) 开始履约
        svc.applyEvent(order.id, new IncomingEvent("evt-2", OrderEvent.START_FULFILL, Map.of()));
        // 4) 妥投完成
        svc.applyEvent(order.id, new IncomingEvent("evt-3", OrderEvent.DELIVERED, Map.of()));

        System.out.println("final state = " + repo.findById("o1").get().state); // COMPLETED
    }
}
```



### **设计要点（大厂里普遍做法）**

- **转移表配置化**：把 List<Transition> 拆成 YAML/DB 配置或代码生成，方便灰度与差异化流程（如品类不同，转移不同）。
- **幂等**：所有外部事件（支付回调、物流回调、人工操作）必须带唯一 eventId，状态机内做一次性消费。
- **并发控制**：数据库用**乐观锁**（version 字段）；极端情况下可在订单维度加分布式锁，但优先乐观锁+重试。
- **Outbox/事务消息**：在**同一事务**里写订单 & outbox 表，异步投递到 MQ，确保“状态变化 → 事件通知”不丢失。
- **可观测性**：每次转移落一条审计日志（from, event, to, operator, reason），便于风控/客服排障。
- **非法转移即失败**：表中**未声明**的转移一律视为**非法**，抛错或告知前端不可操作。
- **Guard 抽象**：把风控、时效、库存、售后规则封进 Guard，状态机保持“流程纯净、规则可替换”。