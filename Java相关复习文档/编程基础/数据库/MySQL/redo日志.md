# redo日志

## 什么是redo日志

InnoDB采用页为单位管理存储空间，我们对一张或多张表进行增删改查都必须将数据所在的页面从磁盘中加载到内存中，

在数据库的持久性特性里，如果一个事务已经提交了，数据是不允许被丢失的，称为持久性，当我们在内存中修改完数据后，并且提交事务了，此时机器突然断电或其他原因，导致内存中的数据丢失了，

这就不符合一致性的要求了，因此为了保证持久性，我们可以将数据写入磁盘后，再让事务返回提交成功，但是这么做会有一些问题：

刷新完整的数据页太浪费。一个页面16个字节，如果一个事务只修改了一个页面的一个字节，也进行刷盘，会太浪费资源。

随机刷新页面太慢。一个事务操作可能同时操作了太多的页面，这些页面在磁盘中并不相邻，这时磁盘需要随机IO刷新，速度太过于慢。

## redo日志格式

一条redo日志格式如下

![img](image/format,png.png)

1. type: 该日志的类型
2. space ID: 表空间ID
3. page number: 页号
4. data: redo日志的具体内容

### 1. 简单的redo日志类型

在对页面的改动比较简单的情况下，只需要记录对某个页面的某个偏移量进行了几个字节的修改，修改后的内容是什么，简单的redo日志类型有下面几种：

1. mlog_1byte
2. mlog_2byte
3. mlog_4byte
4. mlog_8byte
5. mlog_write_string

上面1-4的类型是一样的，仅仅是data长度不同，最后一个string，意味着不能确定具体数据占用多少字节，所以需要在结构中新增一个len字段：

![img](image/format,png-20220928102103557.png)

#### Max Row ID

Innodb中，一张表既没有主键，又没有不可为空的唯一索引时，将会为表添加一个名为row_id的隐藏列作为主键。

row_id的赋值方式如下：

MySQL会在内存中维护一个全局变量，每次隐式列新增一条记录，将把当前的全部变量值赋值给这个隐式列，并且全局变量自增1。

当该全局变量值为256的倍数时，将变量刷到系统表空间页号为7的页面中一个名为Max Row ID的属性中，之所以不每次都刷，是为了避免频繁刷盘带来性能影响。

MySQL重启时，将磁盘中的该值加载到内存中，并且加上256(避免上次重启时没刷盘，实际内存中大于磁盘的值，导致重复)。
Max Row ID 占用8字节的空间，因此写redo log时，类型就是 mlog_8byte 。

### 2. 复杂的redo日志类型

绝大多数的一条SQL，执行一条语句时，会修改非常多的页面，系统数据页面、用户数据页面(聚簇索引、二级索引)，以insert为例，既要更新索引，也可能更新系统数据页面中的Max Row ID，具体如下：

1. 一个表中有多少索引，insert时就需要修改多少B+树
2. 对于一颗B+树，需要更新叶子节点页面，也可能更新内节点页面，还可能创建新页面
3. 更新Page Directory中的槽信息
4. 更新Page Header中的统计信息，page_n_dir_slots、page_heap_top、page_n_heap....
5. 维护上一条记录的next_record指向

**这么多的修改，按照上面说的简单日志类型记录实现，有两种方案**：

1. 在每个修改的地方加上一条redo日志。
2. 将整个页面第一个修改的字节到最后一个修改字节之间所有的数据当成一条redo日志中的数据。

这两种方式都有一些弊端，第一种，如果一个页面中修改的地方太多，可能redo日志占用的空间比整个页面都多，第二种，如果第一个字节到最后一个字节之间有很多没有修改的地方，放到redo中又太浪费空间。

**因此Innodb根据不同的操作，设计了不同的日志类型**：

1. mlog_mlog_rec_insert：插入一条使用非紧凑行格式的记录
2. mlog_comp_rec_insert：插入一条使用紧凑行格式的记录
3. mlog_comp_page_create：创建一个使用紧凑行格式记录的页面
4. mlog_comp_rec_delete：删除一条使用紧凑行格式的记录
5. mlog_comp_list_start_delete：删除多条紧凑行数据的开始
6. mlog_comp_list_end_delete：删除多条紧凑行数据的结束
7. mlog_zip_page_compress：压缩一个数据页

例如mlog_comp_list_start_delete和mlog_comp_list_end_delete，如果是区间删除，每条记录都使用redo记录，那么将会占用很多的空间，用start和end可以节约空间。

**redo日志/逻辑层面含义/物理层面含义**

从物理层面来看，redo日志是记录了哪些表的哪些页面改成了什么值，但是很多时候并不能直接将这种日志直接作为恢复页面的手段，

例如一条insert记录，其中并不会记录将页面中的 page_n_dir_slots、page_heap_top、page_n_heap 改为什么，只是将该页面中插入一条记录的必备要素记录下来，

恢复时，将调用向某个页面插入一条记录的相关函数，redo日志中的记录参数，将被作为函数入参，page_n_dir_slots、page_heap_top、page_n_heap通过调用函数来恢复到崩溃前的样子，这就是逻辑层面的意思。

## Mini-Transaction(MTR) 以组的形式写入redo日志

一条SQL执行的过程中，可能会修改多个页面(系统表空间、聚簇索引、二级索引)，在执行的过程中产生的redo日志，被划分为若干个不可分割的组：

1. 更新Max Row ID属性为一组，不可分割。
2. 向聚簇索引插入一条记录为一组，不可分割。
3. 向二级索引插入一条记录为一组，不可分割。
4. 其他。

### 不可分割的含义

向一个B+树中新增一条记录时，可能会发生下面两种情况：

乐观插入：该页面剩余空间足够充足，直接将该记录插入该页面，然后记录一条 mlog_comp_rec_insert 类型的redo日志。

悲观插入：该页面剩余空间不足，需要分裂新的页面，将原先数据页的一部分复制到新的数据页，然后再将记录插入进去，再将该叶子节点加入到叶子节点链表中，最后在内节点中添加一条目录项指向新创建的页面，这个过程会产生很多的redo日志。

redo日志为了实现MySQL崩溃重启时，恢复到崩溃前的状态，如果悲观插入的过程中只执行了部分，那么恢复时B+树将被恢复为一种不正确的状态，

因此Innodb要求执行这些需要原子性的操作时，必须以组的形式记录redo日志，恢复时要么全部恢复，要么一条也不恢复。

### redo原子性的实现

Innodb使用下面两种方式判断redo是否满足原子性的要求。

需要原子性操作的redo日志，在结束时追加一条类型为 mlog_multi_rec_end 的redo作为结尾。

只有一条redo日志，判断redo的type字段的第一个bit是否为1，为1代表只有一条日志，没有上面的结尾。

## 小结

一个事务会产生多个语句，每个语句会产生多个MTR，每个MTR又包含若干个redo日志。

![image-20220928102452941](image/image-20220928102452941.png)