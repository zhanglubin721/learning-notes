## **一、整体目标：MySQL 如何做到“宕机数据不丢”？**

MySQL **主要依靠三大日志机制协同工作**：

| **日志**     | **作用**                                                     |
| ------------ | ------------------------------------------------------------ |
| **Redo Log** | 保证崩溃恢复（Crash Recovery）：**已提交事务的数据写入磁盘** |
| **Undo Log** | 支持事务回滚、MVCC，**撤销未提交的事务**                     |
| **Binlog**   | 用于主从复制、点时间恢复（PITR），**记录逻辑变更语句**       |

这三者**分工明确又相互配合**，共同保障数据完整性和事务的ACID。



## **二、写入流程与日志协同机制**

以下以 **InnoDB + Binlog格式为ROW的配置（最常见）** 为例说明事务提交过程：



### **1. 执行 SQL**

客户端发来一条写操作，例如：

```
BEGIN;
UPDATE user SET name = '老王' WHERE id = 1;
COMMIT;
```



### **2. InnoDB 写 Undo Log（撤销日志）**

- 在修改数据前，先将旧值写入 Undo Log。

- Undo Log 保存在表空间中，用于：

  - 回滚事务
  - 实现 MVCC（快照读）

  

### **3. InnoDB 写 Redo Log（重做日志）**

- 把修改后的新值写入 redo log buffer（内存中的重做日志缓存）
- 然后刷入 Redo Log 文件（顺序写） → **称为 prepare 状态**



### **4. 写入 Binlog（逻辑日志）**

- MySQL Server 层记录 Binlog（ROW 格式会记录改动后的行内容）
- 也写入 Binlog Cache，最后刷入 Binlog 文件



### **5. 两阶段提交（事务原子性保障）：**

这是 **InnoDB 和 Binlog 协同的关键点**：

- InnoDB prepare Redo Log（预提交）
- Server 层写 Binlog 并 flush
- MySQL 通知 InnoDB：Binlog 写成功，事务可以提交
- InnoDB 写入 Redo Log commit 标志 → 表示事务真正完成



### **为什么这么设计？**

避免以下场景出错：

- Redo Log 写了，但 Binlog 没写 → 主从复制数据不一致
- Binlog 写了，但 Redo Log 没 commit → 主库恢复后找不到事务

> **因此“两阶段提交”机制，保证了 Binlog 和 Redo Log 的原子一致性。**



## **三、崩溃场景下的恢复策略**

| **崩溃场景**                          | **恢复机制说明**                                             |
| ------------------------------------- | ------------------------------------------------------------ |
| 崩溃前事务已提交（Redo 有 commit）    | InnoDB 通过 Redo Log 进行恢复，**重做已提交但未刷盘的数据页** |
| 崩溃前事务未提交（只有 prepare）      | Redo Log 检测到无 commit 标记 → **自动回滚（丢弃 prepare 数据）** |
| 崩溃时 Binlog 写了，但 Redo 没 commit | 不可能！因为两阶段提交顺序要求：**先 Binlog，再 commit Redo**，否则不会写 binlog |
| 崩溃时 Redo commit 了，但 Binlog 没写 | 不可能！同上，两阶段提交机制可避免                           |

> ✅ 只要 **Redo + Undo + Binlog** 写入机制正确，MySQL **不会产生提交一半的脏数据，也不会造成主从不一致**。





## **四、三大日志简要对比总结**

| **类型** | **写入时机**              | **写入位置**          | **功能**               | **与谁协作？**         |
| -------- | ------------------------- | --------------------- | ---------------------- | ---------------------- |
| Redo Log | 事务执行中、提交前        | InnoDB 独立文件       | 恢复已提交事务的修改   | Binlog 两阶段提交      |
| Undo Log | 每次修改前                | 表空间（系统表）      | 支持回滚和 MVCC 快照读 | 与 MVCC 协同           |
| Binlog   | 提交前（redo prepare 后） | Server 层 binlog 文件 | 主从复制、备份、恢复   | 与 Redo 两阶段协同提交 |



## **五、经典面试题（推荐你试着回答或记住）**

1. **MySQL 如何保证崩溃恢复后数据不丢失？**
   - Redo Log 重做已提交事务，Undo Log 回滚未提交事务，Binlog 用于复制和备份。
2. **Binlog 和 Redo Log 为什么都需要？能否只用一个？**
   - Redo 是物理日志，用于崩溃恢复；
   - Binlog 是逻辑日志，用于复制和恢复；
   - 两者协同，通过“两阶段提交”机制保持一致。
3. **在崩溃恢复中，MySQL 如何判断一个事务是否已经提交？**
   - 看 Redo Log 是否有 commit 标志。
4. **在主从复制场景中，Binlog 写了但 Redo 没 commit，怎么办？**
   - 设计上不会发生这种情况（两阶段提交防止了这个问题）。



## 时序图（重点）

```
时序图图例：
Client         MySQL Server层        InnoDB引擎        redo log      binlog
  │                   │                  │               │             │
  │  SQL语句到达       │                  │               │             │
  ├─────────────────▶ │                  │               │             │
  │                   │                  │               │             │
  │                   │   生成执行计划     │               │             │
  │                   ├────────────────▶ │               │             │
  │                   │                  │               │             │
  │                   │   执行写入操作     │               │             │
  │                   ├────────────────▶ │               │             │
  │                   │                  │ prepare阶段    │             │
  │                   │                  ├──────────────▶│             │
  │                   │                  │ 写入redo log   │             │
  │                   │                  │ 状态=prepare   │             │
  │                   │                  │ 刷盘（物理）     │             │
  │                   │                  │                │             │
  │                   │                  │                │             │
  │                   │  写入binlog缓存  	│                │             │
  │                   ├──────────────────────────────────────────────▶  │
  │                   │                  │                │             │
  │                   │  刷盘 binlog    	│                │             │
  │                   ├──────────────────────────────────────────────▶  │
  │                   │                  │                │             │
  │                   │ 通知 InnoDB commit│                │             │
  │                   ├────────────────▶ │                 │            │
  │                   │                  │ redo log commit │            │
  │                   │                  ├──────────────▶ │             │
  │                   │                  │ 状态=commit     │             │
  │                   │                  │                │             │
  │                   │ 返回客户端 OK      │                │             │
  ├◀─────────────────┘                   │                │             │
  │
```



| **崩溃位置**                                                 | **崩溃点说明**                        | **结果（数据是否落盘）** | **binlog 会被主从同步？** | **崩溃恢复后 InnoDB 数据状态**                               |
| ------------------------------------------------------------ | ------------------------------------- | ------------------------ | ------------------------- | ------------------------------------------------------------ |
| ① 写入 redo log prepare 之后，但未写 binlog                  | redo 有，binlog 无                    | ❌                        | ❌                         | redo log 无法 commit，恢复时回滚（因为没有对应 binlog）      |
| ② redo prepare + binlog 写入成功但尚未 commit redo           | **binlog 已持久化，redo 还未 commit** | ❌（事务未完成）          | ❌（binlog 无效）          | crash recovery 阶段检测到 redo 不是 commit 状态，回滚；binlog 不会被同步 |
| ✅ 安全写入点：redo prepare + binlog 写入成功 + redo commit 成功 |                                       |                          |                           |                                                              |
| ③ 所有日志都已写入并 commit，返回客户端成功                  | 全部持久化                            | ✅                        | ✅                         | 数据持久化成功，主从都能复制                                 |



**为何不能只看 binlog？**

MySQL 的主从复制是基于 binlog 的，但 binlog 的有效性依赖于 redo log 是否 commit。

InnoDB 的崩溃恢复只认 redo log；MySQL 的主从同步只认 binlog。但 **只有两者一致（即：2PC 全部完成）才代表数据写入成功且可被同步**。



**2PC 写入流程关键点**

- **prepare 阶段**：InnoDB 先写入 redo log（状态为 prepare）并刷盘
- **binlog 写入并刷盘**
- **redo commit 阶段**：只有在 binlog 成功后，才通知 InnoDB commit redo
- 若任何阶段宕机，只有 redo = commit 且 binlog 存在的事务才有效