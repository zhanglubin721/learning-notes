# **总览：四个概念各司其职**

- **LSN（Log Sequence Number）**：全局递增“时间戳”。写入发生的先后顺序与页版本的基准。每个数据页头都有**页 LSN**；redo 日志、checkpoint 也用 LSN 记录进度。
- **双写缓冲（Doublewrite）**：**防止半页写（torn page）**的“页级保险”。脏页真正回表空间前，先顺序写入一块安全缓冲区并 fsync，崩溃后可用它修复撕裂页。
- **Change Buffer（变更缓冲）**：只针对**二级索引叶子页**且该页不在内存时，把“插/删/改索引条目”的意图**缓存在系统表空间的一棵 B+Tree**中，等目标页以后被读入或后台再合并，减少随机 I/O。
- **AHI（Adaptive Hash Index，自适应哈希）**：InnoDB **自动**在热点范围上构建的**内存哈希索引**，命中后可 O(1) 直达页/记录，绕过多层 B+Tree 查找。





# **LSN：写入顺序与恢复的“尺子”**

- **在哪里**：页头存“页 LSN”；redo 文件与 checkpoint 也带 LSN。

- **干什么**：

  - 判断“某页是否需要用 redo 重做”：页 LSN < redo 的目标 LSN ⇒ 需要重做。
  - 控制恢复起点：从 **checkpoint LSN** 之后的 redo 逐步重放。

  

- **要点**：LSN 不是日志本身，只是顺序号；它把页、redo、checkpoint 三者“对齐”到同一时间线。





# **双写缓冲（Doublewrite）：防撕裂页的两段式写**

## **为什么需要**

单次写 16KB 页，宕机/掉电可能造成**半页写**，页内容“半新半旧”。redo 假设“基页是完整的一版”，遇到撕裂就无法安全重放。



## **为什么会出现“半新半旧”？**

核心在于：**redo 只能保证“页能被重放到最新版本”，但它假设“页是完整的”**。

- InnoDB 的页是 16KB。
- 写入磁盘时，操作系统/硬件通常不会保证「16KB 写入要么全成功，要么全失败」。
- 宕机/掉电可能只写成功了前 8KB，后 8KB 还没来得及写，就挂了。
- 这样磁盘上的页 = 前半部分新版本、后半部分旧版本。



## **怎么做（正常运行时）**

1. **先写双写区**：把将刷新的若干页批量、**顺序**写入双写缓冲（8.0 可在独立文件并行写），并 fsync。
2. **再写目标位置**：将这些页各自“散写”到对应表空间/文件中的真实位置。
3. **Checkpoint 推进**：随着脏页落盘与 redo 持久化，推进检查点 LSN。



## **崩溃恢复时**

1. **先修页完整性**：扫描双写区；若发现某目标页在“散写”时撕裂，则用双写区中的**完整副本**覆盖修复。
2. **再重做 redo**：从 checkpoint LSN 起应用 redo，把“已持久化的更改”补到各页（包括刚修复的页）。

> **角色分工**：**Doublewrite** 只保证“写回的页是完整的一版”；**Redo** 负责“把页重做到该有的版本（按 LSN）”。





## **成本与参数**

- 额外一次顺序写 + fsync，现代 SSD/ NVMe 上常见 5–10% 开销，换来强恢复能力。
- 常用参数：innodb_doublewrite=ON（强烈建议开启）；8.0 的并行双写相关参数（随版本实现演进）。
- 观测：SHOW ENGINE INNODB STATUS\G 的 *Double write* 段、INFORMATION_SCHEMA.INNODB_METRICS（dblwr%）。



## **双写缓冲到底“缓”的是什么**



**双写缓冲缓的是：即将刷盘的“新页”的完整 16KB 镜像**（一批脏页的全页副本），不是旧页、也不是 redo 的内容。





**它为什么要缓“新页”**

- 磁盘/文件系统**不保证 16KB 原子写**，掉电/宕机可能出现**撕裂页（半新半旧）**。
- **redo 是增量日志**，需要在“**完整的一版页**”上才能重放。
- 因此先把**将要写回的那一版完整新页**安全落一次（顺序写、fsync），出故障时就能用它**修复撕裂**，然后再用 redo 把页前滚到最新 LSN。





**它什么时候缓**

- **每次刷脏页**时：后台把 Buffer Pool 中挑选的一批脏页（数据页、索引页等）**先**写到双写区（顺序写 + fsync），**再**散写到各自表空间的最终位置。





**它怎么缓（流程）**

1. 选出要刷的脏页集合 P1..Pn（每页都是**新内容**）。
2. **顺序写**：把 P1..Pn 的**完整 16KB 镜像**按页连续写入**双写区**，并 **fsync**。
3. **散写**：将同样的页内容分别写到各自 .ibd/表空间中的真实位置。





> 崩溃恢复：

- > 若某目标页在第 3 步发生撕裂 → 用双写区里对应的**完整新页**覆盖修复该页；

- > 之后从 checkpoint LSN 起**重放 redo**，把所有页补到应有版本。







**它不是什么（易错点）**

- **不是**“旧页备份”（不是把老版本页先保存一份）。
- **不是**redo 的缓存（redo 是单独的日志文件，先写日志是 WAL 的职责）。
- **不是**长期归档区（双写区循环复用，只是刷盘时的**临时安全缓冲**）。







**和 redo 的分工（记忆法）**

- **Doublewrite**：保证“**页写回始终是完整的一版**”（提供**完整新页**基底）。
- **Redo**：保证“**已经持久化的修改能前滚**”（在完整页上应用**增量**）。







**位置与开销（实现要点）**

- 5.6/5.7：双写区在**系统表空间**（约 2MB 连续区域）；
- 8.0：支持**并行双写文件**，吞吐更好；
- 代价：一次额外**顺序写 + fsync**，现代 SSD 上常见 **5–10%** 开销，换取强 crash-safe 能力。
- 建议：生产环境**保持开启**（innodb_doublewrite=ON）。



> 结论再强调一次：**双写缓冲缓的是“新页的完整镜像”**。它先把这版新页安全落一次盘，确保一旦目标位置写半截，恢复时能用这份**完整新页**修复页面，再由 **redo** 把数据推进到最新。





## **双写缓冲的安全保障机制总结**



**1. 双写是如何保证数据页安全的**

- **问题背景**：磁盘写入 16KB 页不是原子操作，宕机/掉电可能导致只写了一半 → **撕裂页（半新半旧）**。此时 redo log 虽然有增量记录，但无法应用到损坏的基页上。

- **双写的机制**：

  1. 每次脏页写盘前，InnoDB 会先把**完整的新页镜像**顺序写到双写区（连续空间），并 fsync 保证落盘。
  2. 然后再把这些新页写到各自表空间的目标位置（随机写）。

  

- **恢复时**：

  - 如果发现目标页 torn page（checksum/LSN 校验失败），就用双写区里保存的**完整新页镜像**覆盖修复该页。
  - 随后再利用 redo log，把该页推进到最新 LSN。

  

- **结论**：双写缓冲保证了“基页必然完整”，即使目标页撕裂，也能从双写区拿到完整页作为 redo 的应用基底，从而保证安全恢复。





**2. 双写区损坏为什么也不影响数据修复**

- **场景**：如果双写区自身 torn page（比如写新页镜像时宕机），InnoDB 在恢复时会发现校验失败。

- **此时的情况**：说明写到双写区失败 → 很可能目标表空间页还没开始写 → 那么目标页依旧是**旧的完整页**。

- **恢复处理**：

  - InnoDB 会丢弃损坏的双写副本，不去覆盖目标页；
  - 直接用目标表空间里的**旧页**作为基底，再依赖 redo log 把它前滚到最新版本。

  

- **结论**：即便双写区损坏，仍然存在一份完整的基页（旧页），redo 依然能应用 → 数据不会因此丢失。





**3. 总体逻辑**

- **双写的核心作用**：保证在任何时刻，InnoDB 总有一份**完整基页**存在：

  

  - 如果目标页写坏 → 用双写区的完整新页修复；
  - 如果双写区写坏 → 目标页还是旧页，redo 可以补齐。

  

- **redo 的角色**：负责把基页前滚到最新；但 redo 前提是页必须完整。

- **双写的意义**：确保“完整页基底”永远存在，为 redo 提供坚实基础。





------



✅ **一句话总结**

双写缓冲不是为了加速，而是为了保证：**目标页 torn 时有双写区的新页镜像可修复，双写区坏时目标页仍是旧页可配合 redo 前滚**。无论哪种情况，总能保证基页完整，数据安全。





# **Change Buffer：二级索引叶子的“延迟合并”**



## **解决什么**

当目标**二级索引叶子页不在 Buffer Pool**时，直接更新会引发**随机读**把页拉进来；Change Buffer 让我们先把“要插/删/改的条目”**缓存在系统表空间的一棵 B+Tree（ibuf）**里，**以后**再合并到目标页，显著减少随机 I/O。



## **什么时候生效**

- 仅对**非唯一**二级索引叶子页（唯一索引要当场校验，不可缓）。
- 目标页**不在内存**时才缓；在内存就直接改页（变脏）。



## **数据一致性与持久性**

- **Change Buffer 本身是持久化页**（在系统表空间），修改它会像普通页一样：进 Buffer Pool、**写 redo**、刷盘走 **doublewrite**。
- **合并发生时**（目标叶子页被读入或后台线程）：把 ibuf 中对应变更应用到该页 ⇒ 这一步也会产生 redo。



## **宕机恢复如何保证不丢**

- 重启先用 **doublewrite** 修任何撕裂页（包括 ibuf 页与普通索引页）。
- 然后按 **redo** 把**ibuf 自身**与**已发生的合并**都恢复出来。
- 尚未合并的 ibuf 记录仍保留，**等目标页首次被读入时再合并**（或后台慢慢合并）。



## **参数与观测**

- innodb_change_buffering=all|inserts|deletes|none（缓哪些操作）
- innodb_change_buffer_max_size（最多占 Buffer Pool 的比例，%）
- 观测：INNODB_METRICS 中 ibuf_%、SHOW ENGINE INNODB STATUS\G 的 *Ibuf* 段。





# **AHI（自适应哈希索引）：热点直达的内存哈希**

- **自动构建**：InnoDB 观察到某些索引范围被频繁等值/前缀等值命中，会在 Buffer Pool 之上生成哈希条目（*键前缀 → 页/偏移*映射）。
- **命中即 O(1)**：绕过多层 B+Tree 查找。
- **读多写少收益大**；写多可能让哈希维护成本上升。
- **开关**：innodb_adaptive_hash_index=ON|OFF；观测 SHOW ENGINE INNODB STATUS\G（*hash searches/s* vs *non-hash searches/s*）。





# **三者联动（含 LSN）的“时间线”——一次 DML 到崩溃恢复**

## **正常写入路径**

1. **修改 Buffer Pool**：相关页（数据页/二级索引页/分裂页…）被更新为**脏页**，页头记录**新页 LSN**。

2. **写入 redo log buffer**：为每个被改的页记录“页号 + 偏移 + 新值”（按 LSN 递增）。

3. **事务提交**：

   - innodb_flush_log_at_trx_commit=1 ⇒ 提交时把 redo 持久化 + fsync（WAL 保障）。
   - 数据页**无需**同步落盘（稍后刷）。

   

4. **后台刷脏页（Checkpoint 推进）**：

   - 刷页前 **先写双写缓冲**并 fsync；
   - 再把页“散写”到目标表空间位置；
   - 推进 **checkpoint LSN**。

   

5. **二级索引特殊路径（Change Buffer）**：

   - 若目标二级索引叶子页**不在内存**：把变更多写一份到 **Change Buffer 的页**（这一步本身也写 redo）；
   - 将来该索引页被读取或后台触发时再**合并**（合并也写 redo）。

   



## **崩溃恢复路径**

1. **双写修页**：先用 doublewrite 区修复任何**撕裂页**（确保每一页都“完整”）。
2. **redo 重做**：从 **checkpoint LSN** 起，按页把所有已持久化的 redo 应用到数据页、二级索引页、**Change Buffer 页**、undo 页等。
3. **合并延续**：尚未合并到目标二级索引页的 ibuf 记录仍然存在；待目标页被第一次读取或后台合并时再应用（生成新的 redo）。





> **关键心智模型**：

- > **Redo**：按 LSN 把“哪些页、哪些字节、如何改”补齐到最新状态。

- > **Doublewrite**：确保“被写回的页必然是完整的一版”，从而让 redo 可安全重放。

- > **Change Buffer**：把“针对二级索引叶子页的更新意图”持久化**缓存在另一棵 B+Tree**，等目标页显性/隐性触发合并再应用。





## **常用参数与建议（速查）**

- **事务持久性**：innodb_flush_log_at_trx_commit=1（强一致；改为 2/0 有丢事务风险）。

- **双写**：innodb_doublewrite=ON（默认开，生产勿关）；8.0 可用并行双写提升吞吐。

- **变更缓冲**：innodb_change_buffering=all（默认）；写入非常密集、索引多且查询实时性强时，可评估调小/关闭。

- **AHI**：innodb_adaptive_hash_index=ON（默认）；若观测到 AHI latch 冲突或收益不显著可关闭对比。

- **观测**：

  - SHOW ENGINE INNODB STATUS\G（*Double write/Ibuf/Hash searches/s*）
  - INFORMATION_SCHEMA.INNODB_METRICS（dblwr% / ibuf% / buffer_pool% 等）

  



## **一句话回顾**

- **LSN** 把页、redo、checkpoint 串在同一时间轴上。
- **Doublewrite** 让“页写回”永远是完整的一版，**Redo** 再把页补到应有版本。
- **Change Buffer** 把“二级索引叶子页的修改意图”**先持久化缓存在别处**，以后再合并到目标页。
- **AHI** 则是自动的**内存级加速器**，为热点等值查找提供 O(1) 直达。



# 页结构



## **1. 页的整体结构**

InnoDB 的数据页大小固定为 **16KB**，大体上分为几块：

```
+-----------------------------+
| 页头 (File Header)          | 38B
| FSP_HDR / IBUF / XDES 等    | 可选，依页类型不同
+-----------------------------+
| Page Header (专属页头)      | 56B
+-----------------------------+
| Infimum / Supremum 伪记录   | ~26B
+-----------------------------+
| 用户记录区 (User Records)   |
+-----------------------------+
| Free Space (空闲空间)       |
+-----------------------------+
| Page Directory (目录槽)     | 2B * N
+-----------------------------+
| File Trailer (校验信息)     | 8B
+-----------------------------+
```





## **2. FIL/FSP/IBUF**

这是在 **页头 (File Header)** 或紧随其后的特殊区域，主要是全局/表空间管理的信息：

- **FIL (File Header)**

  - 页号（Page Number）、校验和（Checksum）、上一页/下一页指针、日志序号 (LSN) 等。
  - 用于在 Buffer Pool、redo 恢复时快速定位、校验页。

  

- **FSP_HDR (File Space Header)**

  - 只出现在表空间的第 0 号页，用来管理整个表空间的段、区 (extent) 分配情况。
  - 包含 free list、空闲 extent、已用 extent 等信息。

  

- **IBUF (Insert Buffer Bitmap)**

  - 出现在段管理页中，用来标记某个 extent 上哪些页可以被 change buffer 使用。
  - 这是和 **Change Buffer（插入缓冲）**关联的元数据，方便定位可缓冲的页。

  





## **3. Infimum / Supremum 伪记录**

- 在每个页的 **用户记录区最前面**，固定存在两条“虚拟记录”：

  - **Infimum**：比页内任何用户记录都小。
  - **Supremum**：比页内任何用户记录都大。

  

- 作用：

  - 维护页内记录的有序性（B+树的叶子节点、非叶节点都依赖顺序）。
  - 方便链表扫描：用户记录总是落在 Infimum 和 Supremum 之间。

  





## **4. Page Directory（目录槽）**

- 位于页的底部，用于加速查找。

- 内容：一组 **2 字节槽 (slot)**，每个槽指向某个记录的偏移量。

- **槽数量 < 记录数量**：并不是每条记录都有槽，InnoDB 采用“分组”方式，把一组记录挂到一个槽下面。

- **功能**：支持**二分查找**，避免全页顺序扫描。

  - 比如要找某个 key，先在槽里二分定位到大致范围，再顺序扫该槽下的记录链。

  





## **5. 行为上的联系**

- **页头 (FIL/FSP/IBUF)**：元信息 + 管理表空间、链表关系。
- **Infimum/Supremum**：保证页内记录链始终有边界。
- **目录槽**：提高页内搜索效率，从 O(n) 降到 O(log n + k)。
- **数据记录区**：实际存放用户行或索引键。



# 行格式

## **1. 行格式简介**

InnoDB 目前主要用到的行格式有：

- **COMPACT**（MySQL 5.0 引入，常见默认格式）
- **DYNAMIC**（MySQL 5.7/8.0 默认）
- （还有 REDUNDANT/COMPRESSED，这里重点不讲）





## **2. COMPACT 行格式**

特点：

- 每一行数据存放在数据页（16KB）里，行头有 **变长字段长度列表** 和 **NULL 值标记位图**。
- **变长列（VARCHAR、VARBINARY、TEXT/BLOB）**：
  - **前 768 字节** 存放在行内（数据页内），
  - 超过 768 的部分单独写到 **溢出页 (Overflow Page)**。
  - 行内保留一个指针指向溢出页。

> 例：一个 VARCHAR(2000) 列，如果数据存了 1500 字节：

- > 前 768 字节放在数据页（行里），

- > 剩余 732 字节存溢出页，行里留个指针。







## **3. DYNAMIC 行格式**

- 与 COMPACT 不同的是，**长列数据几乎全部放在溢出页**。
- 在行内只保存一个 20 字节左右的指针（不再存前 768 字节）。
- 优点：页内行更紧凑，页能容纳更多行，减少页分裂，节省 Buffer Pool 空间。
- 缺点：读取长列时，需要额外读取溢出页。







## **4. 溢出页（Overflow Page）**

- 一个 InnoDB 页大小 = 16KB。
- 当某列太长（大 VARCHAR、大 TEXT/BLOB），无法完整放入当前数据页，就会被切割成若干“片段”存到溢出页。
- 每个溢出页上都有指针，形成链表，最终和行内的“指针字段”关联起来。
- **行溢出 (Row Overflow)**：行内数据放不下，部分列溢出到溢出页的现象。





## **5. 变长列**

- 指定 VARCHAR(n) 的列就是变长列，真实存储时：

  - 前面会有 1~2 字节的长度标记（取决于 n 的大小）。
  - 真正数据放在长度标记后面。

  

- 如果总长度很大（>页剩余空间），触发行溢出 → 溢出页存储。







## **6. 总体对比（COMPACT vs DYNAMIC）**

| **特点**         | **COMPACT**                    | **DYNAMIC**            |
| ---------------- | ------------------------------ | ---------------------- |
| 长列前 768 字节  | 存在行内                       | 不存在行内             |
| 溢出页指针       | 存在行内                       | 存在行内               |
| Buffer Pool 占用 | 较大（因为含前 768 字节）      | 较小（只留指针）       |
| 长列读性能       | 部分情况更快（不必总去溢出页） | 大部分要读溢出页，稍慢 |
| 默认版本         | 老版本常见                     | MySQL 5.7/8.0 默认     |





## **7. 一句话记忆**

- **COMPACT**：长列 = “行内 768 + 溢出页剩余”。
- **DYNAMIC**：长列 = “行内只留指针，数据全在溢出页”。
- **溢出页**：16KB 的单独页，用链表形式存放长列数据片段。
- **行溢出**：行内容过大导致使用溢出页。