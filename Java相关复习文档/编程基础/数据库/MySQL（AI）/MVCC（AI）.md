# MVCC

## **一、MVCC 的核心目标**

MVCC 的目标是：**读取操作无需加锁，也能看到符合事务隔离级别的数据快照**，从而避免读写冲突，提高并发能力。



## **二、MVCC 的核心结构：隐藏列**

InnoDB 在每一行记录后**隐式维护两个隐藏列**，配合 Undo Log，实现多版本管理：

| **隐藏列名** | **含义**                                          |
| ------------ | ------------------------------------------------- |
| DB_TRX_ID    | 当前这条记录是被哪个事务插入/更新的（最近的一次） |
| DB_ROLL_PTR  | 指向 undo log 的指针（可以恢复旧版本）            |

因此，**一行记录 = 实际数据 + 事务 ID + Undo 指针**。



## **三、Undo Log 与版本链**



### **3.1 Undo Log 是什么？**

Undo Log 是一种**回滚日志**，记录了数据被修改前的旧值，**在 MVCC 中用于构造“历史版本”**。

- 类型：

  - insert undo log：插入记录
  - update undo log：更新记录（包含旧值）
  - delete undo log：删除记录

  

### **3.2 构造版本链**

通过 DB_ROLL_PTR，可以将多次更新/删除的 undo log 串成一个**版本链**，就像这样：

```
当前版本（记录 + trx_id=100） 
  ↘ undo log（trx_id=90）
      ↘ undo log（trx_id=80）
```

在读取数据时，MySQL 会沿着这条链向下查找一个符合“可见性规则”的版本。



## **四、可见性判断（版本是否可见？）**



这是 MVCC 的核心逻辑！

当一个事务 T1 读取记录时，MySQL 会根据**Read View（读取视图）**判断该记录哪个版本对它可见。



### **Read View 结构**

在执行第一次“快照读取”时（如 SELECT），MySQL 会生成一个 Read View，它包含以下内容：

- **m_ids**：当前系统中活跃事务 ID 列表（事务尚未提交）
- **min_trx_id**：最小的活跃事务 ID
- **max_trx_id**：系统当前生成的最大事务 ID（下一个将分配的事务 ID）



### **判断是否可见的逻辑：**

对于某条记录的 DB_TRX_ID = trx_id，在当前事务的 Read View 下，判断是否可见（以下逻辑按顺序执行）：

```
1. trx_id < min_trx_id：该版本创建于所有活跃事务之前，✅可见

2. trx_id ∈ m_ids：该版本是活跃事务创建的，❌不可见

3. trx_id > max_trx_id：是未来事务创建的，❌不可见

4. 否则（trx_id ∉ m_ids 且在 min_trx_id ~ max_trx_id 之间）：✅可见
```



## **五、两种读取方式对 MVCC 的影响**

| **读取方式**       | **是否使用 MVCC** | **行为描述**                                          |
| ------------------ | ----------------- | ----------------------------------------------------- |
| 快照读（普通查询） | ✅ 是              | 通过版本链找到一个符合 Read View 的版本               |
| 当前读（加锁查询） | ❌ 否              | 直接读取最新版本，并加锁，例如：SELECT ... FOR UPDATE |



### **快照读的例子：**

```
SELECT * FROM account WHERE id = 1;
```

👉 使用 Read View，走 MVCC，不加锁。



### **当前读的例子：**

```
SELECT * FROM account WHERE id = 1 FOR UPDATE;
```

👉 不走 MVCC，直接读当前版本并加锁。



## **六、MVCC 与事务隔离级别的关系**

| **隔离级别**               | **是否使用 MVCC** | **行为说明**                     |
| -------------------------- | ----------------- | -------------------------------- |
| **读未提交**（RU）         | ❌ 否              | 读取未提交数据，不走 MVCC        |
| **读已提交**（RC）         | ✅ 是              | 每次查询都会生成新的 Read View   |
| **可重复读**（RR）         | ✅ 是              | 同一个事务中只生成一个 Read View |
| **串行化**（SERIALIZABLE） | ❌ 强制加锁        | 不使用 MVCC，读操作也加锁        |



## **七、典型流程示例（RR级别）**

1. T1 开启事务，读取一条记录 SELECT * FROM user WHERE id=1
2. 此时系统生成一个 Read View，记录当前活跃事务集合
3. 如果有 T2 在之后插入/更新这条记录，T1 仍读取不到，因为其版本不满足可见性判断
4. 所以 T1 的“读”在整个事务期间保持一致，确保了“可重复读”



## **八、与 GC 的关系（purge 线程）**

由于历史版本（undo log）用于构造 MVCC，但它不能永远保留：

- purge 线程会在没人再需要某版本时，将其清理（GC）

**判断是否可以清理：**

- 所有未提交事务的 Read View 中都不再需要该 undo log



## **九、总结一张图**

```
        当前版本
         ↓ trx_id = 130
     ┌─> undo log (trx_id = 120)
     │      ↓
     └───> undo log (trx_id = 110)

事务 T 的 Read View:
  min_trx_id = 125
  m_ids = [125, 127, 129]
  max_trx_id = 131

判断版本可见性：
  trx_id = 130 ❌不可见（大于max）
  trx_id = 120 ✅可见（小于min）
  trx_id = 110 上面判断trx_id = 120的时候已经返回了，所以根本不会到这一步
```



## **十、面试常考点回顾**

1. **MVCC 依赖什么结构实现？**

   - 隐藏列（trx_id、roll_pointer）+ Undo Log + Read View

   

2. **快照读和当前读的区别？**

   - 快照读走 MVCC，不加锁；当前读加锁不走 MVCC

   

3. **RC 和 RR 的差别？**

   - RC 每次生成新的 Read View；RR 整个事务期间只生成一个 Read View

   

4. **MVCC 如何解决幻读？**

   - RR 中快照读无法防止幻读；只有当前读（加锁）+ next-key lock 才能避免



# 间隙锁

很好，那我来帮你把刚才关于 **间隙锁** 的所有关键问题和易混淆点做一个完整、清晰的总结，适合放进你的面试/知识笔记中👇



## **什么是间隙锁？**

**间隙锁（Gap Lock）** 是 InnoDB 为了防止“幻读”而在**索引记录之间的间隙上加的锁**，它不锁定具体的记录，而是锁定某个范围，使得其他事务无法在这个范围内插入新的记录。

**举例**

如果表中有索引值：

```
[10], [20], [30]
```

执行如下语句：

```
SELECT * FROM user WHERE age > 10 AND age < 30 FOR UPDATE;
```

会加锁的范围是：

```
(10,20), (20,30)
```

这些范围之间的“空白区域”被锁住，其他事务无法在这些间隙插入数据。



## **间隙锁解决了什么问题？（为什么要加？）**



### 核心作用：防止“写幻”

在事务隔离级别为 **可重复读（RR）** 时，InnoDB 使用 MVCC 保证 **同一个事务中多次查询结果一致（防止读幻）**，但不能阻止 **并发事务向某个范围内插入新数据**。

这就会导致“**写幻读（Phantom Write）**”问题：

- 你以为你处理了范围内的所有记录，结果别的事务插入了新记录你没看到。



### **间隙锁就是为了解决这个问题：**

> **禁止其他事务在你所关注的范围内插入新记录**，从而实现事务级别的数据隔离。



## **哪些场景下会加间隙锁？**

| **语句类型**                                          | **是否加间隙锁** | **说明**                                                    |
| ----------------------------------------------------- | ---------------- | ----------------------------------------------------------- |
| SELECT ...（普通快照读）                              | ❌ 否             | 快照读不加锁，只靠 MVCC                                     |
| SELECT ... FOR UPDATE / LOCK IN SHARE MODE            | ✅ 是             | 当前读，锁住命中的记录和间隙（Next-Key Lock）               |
| UPDATE ... WHERE ...                                  | ✅ 是             | 会加 Next-Key Lock，含间隙锁                                |
| DELETE ... WHERE ...                                  | ✅ 是             | 同上，加间隙锁防止插入幻影数据                              |
| 精确主键查找：SELECT * FROM t WHERE id = 5 FOR UPDATE | ❌ 只加记录锁     | 精确唯一值（唯一索引 + 等值查询）可优化为记录锁，不加间隙锁 |
| 范围查找：SELECT * FROM t WHERE age > 5 FOR UPDATE    | ✅ 是             | 范围查找一定加间隙锁                                        |



### **关键误区澄清**

> **❗ 面试高频误解：普通 SELECT 会加间隙锁？**

❌ 错！只有 SELECT ... FOR UPDATE、UPDATE、DELETE 才会加。

> **✅ 正确理解：间隙锁是为“写安全”服务的，不是为“读一致”服务的。**

**在可重复读下，以下场景不成立**

![image-20250804144908471](image/image-20250804144908471.png)

⬆️⬆️⬆️⬆️⬆️⬆️⬆️**上面这个图里的作者是个大傻子，学艺不精**⬆️⬆️⬆️⬆️⬆️⬆️⬆️⬆️



## **MVCC 与间隙锁的关系**

| **功能**                | **MVCC**   | **间隙锁** |
| ----------------------- | ---------- | ---------- |
| 读一致性（可重复读）    | ✅ 提供     | ❌ 不需要   |
| 防止幻读（插入新数据）  | ❌ 无法防止 | ✅ 必须加   |
| 适用于快照读（SELECT）  | ✅ 是       | ❌ 否       |
| 适用于当前读 / 修改操作 | ❌ 否       | ✅ 是       |

你的同事说得**没错**，**间隙锁（Gap Lock）是否生效，与是否使用唯一索引、非唯一索引、以及是否命中索引、SQL语句的执行计划有关**。我们来详细讲清楚这个结论。





## 什么情况下会加间隙锁

**唯一索引 vs 非唯一索引，加锁行为区别**



### 情况一：唯一索引 + 等值匹配（能命中记录）

```
SELECT * FROM user WHERE id = 10 FOR UPDATE;
-- id 是唯一索引
```

- 加锁类型：**记录锁（Record Lock）**
- 锁定对象：**id=10** 的那一条记录
- **不会加间隙锁！**

> ✅ 只加精确的行锁，因为唯一索引定位精确，不存在“幻写”风险





### 情况二：唯一索引 + 范围匹配

```
SELECT * FROM user WHERE id > 10 AND id < 20 FOR UPDATE;
-- id 是唯一索引
```

- 加锁类型：**间隙锁 + 记录锁**
- 锁定对象：
  - 所有落在 (10, 20) 区间内的实际记录：加记录锁
  - (10, 20) 之间的空隙：加间隙锁

> ❗虽然是唯一索引，但因为是范围查询，可能出现幻写，因此需要间隙锁。





### 情况三：非唯一索引 + 等值匹配

```
SELECT * FROM user WHERE age = 30 FOR UPDATE;
-- age 是非唯一索引
```

- 加锁类型：**记录锁 + 间隙锁（next-key lock）**
- 锁定对象：age=30 的所有记录 + 其对应的间隙

> ❗不能确定将来是否会插入新的 age=30 记录，需防幻写。





### 情况四：主键/唯一索引 + 不存在的值

```
SELECT * FROM user WHERE id = 999 FOR UPDATE;
-- id 是唯一索引，999 不存在
```

- 加锁类型：**间隙锁**
- 锁定对象：包含 999 的那个**间隙**

> ❗需要防止别人**插入这条记录（id=999）**，避免“幻写”。





### **小结表格：唯一 vs 非唯一索引 加锁行为**

| **查询方式**               | **索引类型** | **是否命中记录** | **锁类型**                 |
| -------------------------- | ------------ | ---------------- | -------------------------- |
| WHERE id=10                | 唯一索引     | 命中             | 记录锁                     |
| WHERE id=999               | 唯一索引     | 不命中           | 间隙锁                     |
| WHERE id > 5               | 唯一索引     | 范围查询         | 记录锁 + 间隙锁            |
| WHERE age=30               | 非唯一索引   | 不定（多行）     | 记录锁 + 间隙锁            |
| WHERE name='A'（未加索引） | 无索引       | 全表扫描         | 全表行锁（加在聚簇索引上） |



### **next-key lock 是什么？**

在 RR 隔离级别中，InnoDB 实际用的是：

> **next-key lock = 记录锁 + 前一个间隙锁**

例如：

- 假设索引页上有值：20, 30, 40
- 你执行：SELECT * FROM t WHERE age = 30 FOR UPDATE

此时加锁的是：

- [20,30)：加间隙锁（防止插入新记录）
- 30：加记录锁（锁住已有记录）

所以其实锁住的是 (20,30] 这个区间





### **为什么命中唯一索引不加间隙锁？**

因为：

- SELECT * FROM t WHERE id = 1 FOR UPDATE
- 已知 id 是唯一索引
- 那么：
  - id=1 **存在**：加精确行锁
  - id=1 **不存在**：加 1 所在的间隙锁，防止插入

所以只有等值匹配+唯一索引 **并且记录存在** 的时候，才不用加间隙锁。