### **第十一题（高频索引优化场景）**：

在一张电商订单表 orders 上有如下索引：

```
CREATE INDEX idx_user_status_created
ON orders(user_id, status, created_at);
```

下面有一个查询：

```
SELECT * FROM orders
WHERE status = 1 AND created_at > '2024-01-01';
```

请问：

1. 这个查询能否用到 idx_user_status_created 索引？
2. 为什么可能会发生索引失效？
3. 如果要优化，你会怎么做？



#### 回答

1. 是否能用上 idx_user_status_created

- 索引定义顺序是 (user_id, status, created_at)
- MySQL 使用索引必须满足 **最左前缀原则**
- 查询条件是 status = 1 AND created_at > '2024-01-01'，**缺失了 user_id**
- 所以这个查询 **无法有效利用组合索引**，只能退化成 **全表扫描** 或者只用 status 的索引选择性很差，基本等于没用



2. 为什么可能会发生索引失效

- **原因 1：最左前缀原则** → 必须从索引的第一个字段开始才能利用
- **原因 2：范围查询截断原则** → 一旦遇到范围条件（>、<、BETWEEN、LIKE 'xx%'），后面的列无法继续利用索引排序和筛选



**3. 优化方式**

**根据查询场景重建索引**

```
CREATE INDEX idx_status_created ON orders(status, created_at);
```

- 这样 status 精确匹配 + created_at 范围查询 → 可以走索引
- 如果 select 的字段能被覆盖（比如只查 id、created_at），还能形成 **覆盖索引**，避免回表

**业务层面优化**

- 如果常常以 status + created_at 维度查询，可以考虑冷热数据分表
- 或者增加冗余索引，提升查询速度，代价是写入性能变差

一句面试官喜欢的总结：

> 当前索引设计只适合 (user_id, status, created_at) 的联合条件查询，不包含 user_id 时就失效。应根据实际查询模式调整索引列顺序，或者额外创建 (status, created_at) 索引。



好 👍，我来直接帮你梳理 **第十二题：为什么 SELECT COUNT(\*) 在 InnoDB 下会很慢，以及优化方法**。



------



### **第十二题：为什么 SELECT COUNT(\*) 在 InnoDB 下会很慢，以及优化方法**



- **MyISAM 引擎**：表有一个计数器，能直接返回总行数，所以 COUNT(*) 很快。

- **InnoDB 引擎**：没有全表行数计数器，因为它要保证事务一致性（MVCC），

  - InnoDB 必须逐行扫描（遍历索引 B+Tree 或表数据）
  - 然后根据事务隔离级别判断这行是否对当前事务“可见”
  - 所以性能相对较慢，尤其是大表。

  

#### 回答

**方法一：使用更小的索引**

- COUNT(*) 会选择最小的索引树来遍历
- 如果表上有一个 **很小的二级索引**（比如只有一个 tinyint 列），比遍历聚簇索引快很多

```
SELECT COUNT(*) FROM orders FORCE INDEX(idx_small_col);
```



**方法二：近似统计**

- 如果业务允许用近似值（比如展示页面数量），可以用 **information_schema.tables** 里的 TABLE_ROWS 统计值（非实时，估算）

```
SELECT table_rows 
FROM information_schema.tables 
WHERE table_name = 'orders' AND table_schema = 'mydb';
```



**方法三：额外维护计数表**

- 在应用层或触发器里，维护一个单独的 counter 表来保存行数
- 插入/删除时更新计数，SELECT 时直接读这个计数表 → O(1)



**方法四：分区计数 / 缓存**

- 对于大表，可以按业务维度（比如日期、用户）分区计数
- 或者用 Redis 缓存计数结果，周期性异步刷新



总结

> InnoDB 为了保证事务隔离，没有维护行数计数器，所以 COUNT(*) 必须逐行扫描。优化思路包括：利用最小索引加速、使用近似值、应用层冗余计数，或者缓存结果。具体方案要结合业务是否要求实时精准。



### InnoDB 为什么建议自增主键？用 UUID 做主键会有什么问题？



#### 回答

**1为什么推荐自增主键？**

- **聚簇索引特性**：

  InnoDB 的表数据就是存储在 **聚簇索引（Primary Key B+Tree）** 的叶子节点上。

- **自增主键好处**：

  1. 插入数据时新记录总是追加在索引的末尾 → 避免频繁的 **页分裂、碎片化**
  2. 保证索引有序，减少随机 IO，插入性能高
  3. 查询时，ORDER BY id 可以直接利用索引排序

  

**UUID 做主键的问题**

- **随机性强**：每次插入会“打乱”B+Tree 的顺序，导致频繁的 **页分裂、内存碎片**，严重影响性能
- **存储空间大**：UUID 一般是 36 字符串（或者 16 字节二进制），比 BIGINT(8字节) 要大得多
- **索引膨胀**：主键在 InnoDB 中是聚簇索引，二级索引会引用主键值 → 所有二级索引都变大
- **排序没意义**：UUID 无法直接表示插入顺序，业务查询和分页也会更复杂



**雪花算法 ID（Snowflake ID）优点**

- **有序递增性**：高位是时间戳 → 保证整体趋势递增，避免 UUID 的完全随机性
- **分布式唯一性**：中间几位可以放机器 ID、数据中心 ID
- **性能平衡**：既不会暴露全局自增 ID 的规律，又能避免随机 UUID 带来的碎片化问题



**面试总结版回答**

> InnoDB 推荐自增主键，因为它能保证聚簇索引按顺序插入，避免页分裂和随机 IO，同时天然支持按照插入顺序排序。

> 如果用 UUID 作为主键，会导致索引无序、碎片严重、存储和索引开销大，不适合高并发插入场景。

> 实际业务中，如果担心自增 ID 暴露规律，可以用雪花算法 ID，它在保持全局唯一的同时，仍具备趋势递增性，性能和安全性更均衡。



### **MySQL 为什么需要两阶段提交（redo log + binlog）？单独用其中一个不行吗？**



#### 回答



**redo log 和 binlog 的区别**

- **redo log**（InnoDB 特有，物理日志）：

  - 记录 **数据页的物理修改**（偏移量、数据块变更）
  - 用于 **崩溃恢复**（Crash Recovery），保证事务的 **持久性**

  

- **binlog**（Server 层，全局逻辑日志）：

  - 记录 **数据变更的逻辑操作**（比如 INSERT INTO …）
  - 用于 **主从复制**、数据恢复（Point-in-Time Recovery）

  

**为什么需要两阶段提交**

- 如果只有 **redo log**：崩溃后可以恢复本地一致性，但主从复制就没法保证一致
- 如果只有 **binlog**：能保证主从一致，但本地可能崩溃丢失数据，事务不具备持久性
- 因此必须要保证 **两份日志的数据一致性**



**两阶段提交过程**

1. **写入 redo log（prepare 状态）**

   - 表示事务已经执行完，但未提交

   

2. **写入 binlog**

   - 记录逻辑操作，保证能同步给从库

   

3. **提交 redo log（commit 状态）**

   - 标记事务完成，保证本地持久化

   

这样就能保证：

- 如果 binlog 已写入但崩溃 → redo log 还在 prepare 状态，重启时补 commit，保证一致
- 如果 redo log 已写 prepare 但 binlog 没写成功 → 重启时回滚事务，不影响主从一致



**面试官喜欢的总结**

> redo log 保证 **事务持久性**，binlog 保证 **主从一致性**。

> 两者必须保持一致，否则会出现 **主库和从库数据不一致**。

> 因此 MySQL 使用 **两阶段提交**：先写 redo log（prepare），再写 binlog，最后提交 redo log，确保二者原子性。



### 你怎么分析一条 SQL 为什么慢？EXPLAIN 输出里最重要的字段有哪些？



#### 回答

**type —— 访问类型（最重要指标）**

- 反映了 MySQL 查询使用索引的程度

- 常见值（从好到坏）：

  - system > const > eq_ref > ref > range > index > ALL
  - **重点：ALL 表示全表扫描 → 一般是性能问题**

  

**key —— 实际用到的索引**

- 显示优化器选择的索引
- 如果是 NULL，说明没用上索引 → 需要关注



**key_len —— 索引使用的字节数**

- 可以判断联合索引是否被完整利用
- 如果只用了一部分字段，说明可能没有触发最优索引



**Extra —— 额外信息**

- 常见信息：

  - Using index → 覆盖索引（好事）
  - Using where → 需要通过 where 条件过滤
  - Using temporary → 用到了临时表（可能影响性能）
  - Using filesort → 排序无法用索引完成，需要额外排序

  

**其他辅助字段（面试加分点）**

- rows → 预估扫描的行数（越少越好）
- filtered → 过滤后剩下的行数比例，配合 rows 估算实际扫描代价



**面试总结版回答**

> 我会先看 type，它能快速判断是否全表扫描。

> 再看 key 和 key_len，确认优化器是否用上了正确的索引，是否用全了联合索引。

> 最后看 Extra，关注是否出现临时表和文件排序，这往往是 SQL 性能瓶颈的来源。

> 辅助会看 rows 和 filtered 来预估扫描代价。



### 为什么有时候明明建了索引，但 MySQL 执行计划却没有使用？



#### 回答



1. **最左前缀原则没遵守**

   - 复合索引必须从最左边字段开始连续匹配，否则优化器不会使用

   

2. **索引字段被函数/计算包裹**

   - 例如：WHERE DATE(create_time) = '2025-08-20'
   - 优化器无法直接利用索引，需要改写成范围：WHERE create_time >= '2025-08-20 00:00:00' AND create_time < '2025-08-21 00:00:00'

   

3. **范围查询截断**

   - 复合索引 (a, b, c)，如果 a=1 AND b>10，那么 c 就无法利用

   

4. **排序方向不一致**

   - 索引 (create_time ASC, id ASC)，如果 SQL 用 ORDER BY create_time ASC, id DESC → 不能完全利用索引，需要 filesort

   

5. **选择性太差**

   - 比如 status 字段取值只有 0/1，区分度太低
   - 优化器可能判断走索引反而更慢，直接选择全表扫描

   

6. **隐式类型转换**

   - WHERE phone = 12345，而 phone 列是 VARCHAR，会发生类型转换，索引失效
   - 正确写法：WHERE phone = '12345'

   

7. **LIKE 前缀模糊匹配**

   - LIKE '%abc' → 无法走索引
   - LIKE 'abc%' → 可以利用索引

   

**面试总结版回答**

> 索引不生效的常见原因有：

- > 复合索引没遵循最左前缀原则

- > 对索引列做了函数或运算

- > 范围查询导致后续字段无法利用

- > 排序方向和索引不一致

- > 索引字段选择性差，优化器可能放弃索引

- > 隐式类型转换、前缀模糊匹配也会让索引失效

  > 一般要结合 EXPLAIN 看执行计划，确认问题点，然后通过改写 SQL 或调整索引来优化。