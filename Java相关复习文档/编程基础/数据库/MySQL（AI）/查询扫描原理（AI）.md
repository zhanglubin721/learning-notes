# **MySQL InnoDB 数据扫描与 LRU 管理流程总结**



## **一、范围扫描的执行流程**

1. **优化器生成范围**

   - 例如：WHERE id > 10 AND id < 100000 → 转换为索引范围 (10, 100000)。

   

2. **从根页定位起点**

   - B+Tree 根页（非叶子页）存放分隔键，二分查找找到第一个 ≥10 的子页指针。

   

3. **下探到叶子页**

   - 叶子页内记录按主键顺序排列，利用 **Page Directory** 二分找到第一条 id > 10 的记录。

   

4. **顺序扫描叶子页链表**

   - 从起点开始，顺序沿着叶子页的记录和页链表（FIL_PAGE_NEXT）扫描。
   - 碰到 id >= 100000 时立刻停止，后续页不再加载。

   

5. **覆盖索引与回表**

   - **覆盖索引**：所需列都在索引页中 → 只访问索引叶子页，不加载聚簇数据页。
   - **非覆盖索引**：二级索引页提供 (索引列 + 主键) → 需回表到聚簇索引页，根据主键取整行。

   

6. **Index Condition Pushdown (ICP)**

   - 如果条件涉及二级索引列，InnoDB 会在索引层先过滤，减少不必要的回表。

   



## **二、Buffer Pool 与 LRU 队列**

1. **页加载**

   - InnoDB 的最小 I/O 单位是 **页 (16KB)**。
   - 访问到的页（索引页、数据页、undo页等）都会被加载到 Buffer Pool。

   

2. **LRU 双链表管理**

   - Buffer Pool 采用 **分段 LRU**：
     - **young 区**（约 5/8）：热点页。
     - **old 区**（约 3/8）：刚加载的页。
   - 新加载页先放入 **old 区**，只有短时间内再次访问才会晋升到 **young 区**。
   - 目的是防止全表/大范围扫描把热点页冲掉。

   

3. **覆盖索引 vs 非覆盖索引对 LRU 的影响**

   - **覆盖索引查询**：只会把索引页放入 LRU，不会把聚簇数据页加载进来 → 内存占用小。
   - **非覆盖索引查询**：索引页 + 对应的聚簇数据页都会进入 LRU。
   - 范围扫描时，这些新加载的页进入 old 区，不会顶掉热点页。

   



## **三、核心结论**

- **数据访问粒度**：InnoDB 以页为单位读取，条件过滤是“边扫描边判断”。
- **不必要的页不会加载**：范围超过上界时立即停止，未被访问到的页不会读入。
- **覆盖索引更省缓存**：只需索引页，不触碰聚簇页。
- **LRU 策略**：所有被读入的页（索引/数据页）都会放入 LRU 队列；新页进入 old 区，只有被多次访问才会晋升到 young 区。



# 全表扫描污染 LRU



## **1. 全表扫描时会发生什么**

- **访问路径**：优化器选择全表扫描时，InnoDB 会从聚簇索引的**根页**开始，顺序遍历所有叶子页。
- **页加载**：每个叶子页（存储数据行的页）都会被读取到 Buffer Pool 并进入 LRU（先进入 old 区）。
- **索引内部节点页**：为了遍历，也需要从根到叶子链路上的内部节点页，这些页也会进 LRU，但数量远少于叶子页。





## **2. 污染的来源**

- **LRU 污染**的根本原因：大量顺序读，把很多“一次性访问”的页灌进 Buffer Pool。

- 这些页大多数只被读一次，很快就会占据 LRU 的尾部，挤掉真正的热点页。

- InnoDB 针对这个问题做了优化：

  - 新加载的页先放入 **old 区**（3/8），不是直接放到 young 区；
  - 只有在短时间内**再次访问**才会晋升到 young 区。
  - 这样全表扫描的“冷页”很快会被淘汰，减少污染。

  



## **3. 为什么索引页污染相对小一些**

- **页大小都是 16KB**，但内容密度不同：

  - **聚簇索引叶子页**：存放整行数据（可能包含多列，甚至大字段的溢出指针），一页能放的行数相对较少。
  - **二级索引页（索引叶子页）**：存放的是 (索引键 + 主键值)，比整行数据小得多，**相同 16KB 能容纳更多条记录**。

  

- 所以同样扫描 N 条数据，二级索引需要加载的页数 < 聚簇索引需要加载的页数 → 相对更“节省 LRU 空间”。





## **4. 实际结论**

- **是的，全表扫描时所有涉及的页都会进 LRU（索引页、数据页）**，只是这些页大多停留在 old 区，很快就会被淘汰。
- **覆盖索引场景更省内存**：因为只加载二级索引页，不加载聚簇索引页。
- **即便如此，也存在污染**：如果 Buffer Pool 太小，或者并发有多个大扫描，依然会把热点页挤掉。





✅ 总结一句话：

**全表扫描确实会把大量索引叶子页/数据页塞进 LRU，构成缓存污染；区别在于索引页单位容量大、页数少，相对污染轻一点，但本质问题还是依赖 InnoDB 的 old 区策略来缓解。**