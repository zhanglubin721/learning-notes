## **✅ 一、什么是 GC Root（起点）**

**GC Root** 是垃圾回收中进行可达性分析时的**起点引用集合**，它不是“扫描行为的执行者”，而是“从这里开始扫描对象图”的地方。

常见的 GC Roots 包括：

- 每个线程的虚拟机栈中的**局部变量表**（如方法参数、临时变量）
- 类的**静态字段**
- JNI 引用
- 被持有的锁对象
- Finalizer 队列中的对象

🔹 GC Root 与堆中对象在哪一代（新生代 / 老年代）**无关**。

它只是 GC 的“起始引用源”。



## **✅ 二、Parallel GC 和 G1 GC 中新生代回收（Young GC）的流程**

这两个 GC 的 Young GC 过程都是：

> **从 GC Root 出发，扫描对象图，但只复制/处理新生代对象。**



### **🔁 1. 通用流程（适用于 Parallel GC 和 G1）**

1. **GC 从 GC Root 中提取所有引用**

2. 判断这些引用指向的对象是否在新生代（Eden / Survivor）

3. 如果是 → 加入“扫描队列”，进行复制并递归扫描

4. 如果不是（即指向老年代）→ 忽略，不处理

5. 除了 GC Root，还需要处理：

   - 老年代中引用新生代的对象（跨代引用）

   

### **⚠️ 2. 为何跨代引用是个问题？**

GC Root 并不会包含**老年代对象的字段引用**

所以：

- 如果老年代对象 A 有个字段 a.child = youngObject
- youngObject 不在 GC Root 路径上
- 又没有其他引用 → 会在 Young GC 中被误回收 ❌

为解决这个问题：



### **📌 3. Parallel GC 的方案：卡表（Card Table）**

- JVM 把堆按 512 字节划分为很多卡片（Card）
- 每次有对象写引用时，触发 **写屏障**，将目标地址所在的卡片标记为 dirty
- Young GC 时扫描这些 dirty 卡片中的对象，看它们是否引用新生代对象



### **📌 4. G1 GC 的方案：Remembered Set（RSet）**

- G1 把整个堆划分为多个 Region（无论新生代还是老年代）
- 每个 Region 维护一个 **RSet**（记录谁引用了我）
- 写屏障会将跨 Region 的引用写入对应 RSet
- Young GC 时：
  - 扫描 GC Root
  - 加上当前目标 Region 的 RSet（谁引用了我）
  - 精确扫描这些源 Region 中指向该 Region 的引用



## **✅ 三、总结核心对比（Parallel GC vs G1）**



| **特性**               | **Parallel GC**            | **G1 GC**                         |
| ---------------------- | -------------------------- | --------------------------------- |
| 是否从 GC Root 开始    | ✅ 是                       | ✅ 是                              |
| 是否只处理新生代       | ✅ 是（Eden + Survivor）    | ✅ 是（部分 Region）               |
| 老年代跨代引用记录方式 | 卡表（Card Table）         | Remembered Set（RSet）            |
| 粒度                   | 粗（512B 卡）              | 精细（Region + 引用对象）         |
| 是否扫描整个老年代     | ❌ 否，仅扫描卡表命中的区域 | ❌ 否，仅扫描 RSet 中记录的 Region |

### Young GC阶段扫描GC Root优化

| **优化点**         | **描述**                                                     |
| ------------------ | ------------------------------------------------------------ |
| 代内快速判断       | GC 在扫描任何引用时，先判断对象属于哪一代，避免跨代遍历      |
| 根引用过滤         | GC Root 引用只保留指向新生代的作为起始点                     |
| 辅助数据结构       | 用卡表或 RSet 在 GC 前就知道“从老年代到新生代的跨代引用”在哪，不需全图遍历 |
| 工作队列局部性优化 | GC 扫描时只处理 Eden 和 Survivor 区对象队列，最大化内存局部性和效率 |



## **✅ 总结性一句话：**

> **GC Root 是所有 GC 的起点，它与对象在哪一代无关。Parallel GC 和 G1 的 Young GC 都从 GC Root 出发，但只处理新生代对象。为防止遗漏老年代引用新生代的情况，Parallel GC 使用卡表、G1 使用 Remembered Set 来辅助扫描。**