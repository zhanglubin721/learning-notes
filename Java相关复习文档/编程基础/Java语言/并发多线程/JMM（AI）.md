## 什么是JMM

JMM（Java Memory Model，**Java 内存模型**）是 Java 虚拟机的一部分，定义了**多线程环境下变量的可见性、原子性和有序性规则**，从而屏蔽不同硬件和操作系统之间的内存访问差异。

在并发编程中，多个线程会**共享堆内存中的变量**，但每个线程可能会将变量复制到**工作内存（线程栈中的一块区域）**中进行操作。这个时候就会出现两个问题：

1. **可见性问题**：一个线程修改了变量，其他线程看不到。
2. **有序性问题**：编译器或 CPU 出于优化目的，会调整指令执行顺序，导致预期之外的执行结果。

JMM 就是为了解决这两个问题，确保并发程序在多核 CPU 下仍然行为一致。

JMM 抽象了两类内存：

- **主内存（Main Memory）**：所有线程共享的区域（通常是堆中的变量）。
- **工作内存（Working Memory）**：每个线程私有的，保存了主内存中变量的副本。

每个线程对变量的操作都必须先在工作内存中进行，然后再同步到主内存。

## **JMM 定义的八种操作**

JMM 定义了线程与主内存之间的交互操作（Java 指令层面）：

1. lock：作用于主内存变量，把变量标识为线程独占状态。
2. unlock：释放锁，使变量可以被其他线程访问。
3. read：从主内存读取变量到工作内存。
4. load：把 read 到的值放入工作内存的变量副本中。
5. use：从工作内存使用变量。
6. assign：把值赋给工作内存的变量。
7. store：把工作内存的变量值传给主内存。
8. write：把 store 的值写入主内存变量。

## **JMM 的三大特性**

### **1.** 原子性

- JMM 保证基本数据类型的读取/写入是原子的（除了 long、double 的非 volatile 读写在 Java 5 之前可能不是原子的）。
- synchronized、Lock、volatile 提供更高级别的原子性。

### **2.** 可见性

- 一个线程修改了变量，能及时被其他线程看到。
- 关键字 volatile 保证了可见性。
- synchronized 也能通过内存屏障来实现可见性。

### **3.** 有序性

- 编译器和 CPU 会优化指令顺序。
- JMM 规定了**happens-before** 规则来约束这种乱序执行。

##  **happens-before 规则（重点）**

JMM 用 happens-before 关系来定义操作之间的顺序约束。如果一个操作 A happens-before B，那就说明 A 的结果对 B 可见，并且 A 的执行先于 B。

常见的 happens-before 规则：

| **规则名称**  | **描述**                                                     |
| ------------- | ------------------------------------------------------------ |
| 程序次序规则  | 单个线程内，按照代码顺序执行。                               |
| 锁规则        | 一个解锁操作 happens-before 之后对同一锁的加锁。             |
| volatile 规则 | 对 volatile 变量的写操作 happens-before 后续对它的读操作。   |
| 线程启动规则  | Thread.start() happens-before 该线程中的任何操作。           |
| 线程终止规则  | Thread.join() happens-before 主线程获取子线程的任何结果。    |
| 传递性        | A happens-before B，B happens-before C，则 A happens-before C。 |

## **关键字与 JMM 的关系**

### **volatile**

- 保证可见性
- 禁止指令重排序（有一定的**有序性保证**）
- **不保证原子性**

### **synchronized**

- 保证**原子性**
- 保证**可见性**（通过解锁时将工作内存刷新回主内存）
- 保证**有序性**

| **操作手段**  | **是否保证原子性** | **是否保证可见性**   | **是否禁止重排** | **是否推荐用于自增** |
| ------------- | ------------------ | -------------------- | ---------------- | -------------------- |
| volatile      | ❌ 否               | ✅ 是                 | ✅ 是（部分）     | ❌ 否                 |
| synchronized  | ✅ 是               | ✅ 是                 | ✅ 是             | ✅ 可行               |
| AtomicInteger | ✅ 是               | ✅ 是（借助内存语义） | ✅ 是             | ✅ 推荐               |

## 重点

1.假如我现在能够保证操作基础数据类型int count的临界区互斥（只能被一个锁操作或者多个锁临界区互斥），那即便是基础数据类型的int也不会有线程安全问题

2.假如我现在有多个锁都可以操作count（临界区不互斥），那么此时必须使用原子类，原子类内部通过cas来保证++操作的准确

3.假如我的锁内部就只干了count++这一件事，那连锁都不用加了，直接使用原子类就能保证并发安全



```java
class Worker implements Runnable {
    private volatile boolean running = true;

    public void run() {
        while (running) {
            // 执行任务
        }
    }

    public void stop() {
        running = false;
    }
}
```

4.如果我能保证只有stop方法才能操作running，即不会出现另一个start方法来并发操作running，那么上述写法自己定义一个volatile的布尔值变量是执行效率最高的，因为避免了原子类内部cas操作

5.如果现在还有一个start方法会操作把running置为true，并且可能会stop并发执行，这个时候就必须使用原子类型的布尔值才能保证线程安全