## 什么是JMM

JMM（Java Memory Model，**Java 内存模型**）是 Java 虚拟机的一部分，定义了**多线程环境下变量的可见性、原子性和有序性规则**，从而屏蔽不同硬件和操作系统之间的内存访问差异。

在并发编程中，多个线程会**共享堆内存中的变量**，但每个线程可能会将变量复制到**工作内存（线程栈中的一块区域）**中进行操作。这个时候就会出现两个问题：

1. **可见性问题**：一个线程修改了变量，其他线程看不到。
2. **有序性问题**：编译器或 CPU 出于优化目的，会调整指令执行顺序，导致预期之外的执行结果。

JMM 就是为了解决这两个问题，确保并发程序在多核 CPU 下仍然行为一致。

JMM 抽象了两类内存：

- **主内存（Main Memory）**：所有线程共享的区域（通常是堆中的变量）。
- **工作内存（Working Memory）**：每个线程私有的，保存了主内存中变量的副本。

每个线程对变量的操作都必须先在工作内存中进行，然后再同步到主内存。

## JMM存在的意义

> **Java 内存模型（JMM）是 Java 虚拟机定义的一组抽象规范，用于屏蔽底层硬件（CPU、缓存、总线）和操作系统在并发内存访问上的差异性，向 Java 程序员提供一致的多线程内存可见性和交互语义。**

**📌 二、为什么 JMM 必须存在？**

| **背景**         | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| 不同平台架构不同 | 有些 CPU 支持乱序执行（如 x86、ARM），有些强一致性，有些弱一致性 |
| 硬件缓存不同步   | 多核处理器每个线程有自己的 L1/L2 缓存，变量副本不一致        |
| 编译器重排序     | JIT 编译器 / CPU 为了优化性能会调整执行顺序                  |

🧨 如果没有统一的内存模型：

- **同一段 Java 并发代码**在不同 CPU/操作系统/硬件上可能表现**完全不一样**；
- 程序员将陷入“写了对的代码，在某些平台上却莫名出错”的陷阱。

**🔧 三、JMM 解决了什么？**

| **问题类型**                 | **JMM 的解决方式**                       |
| ---------------------------- | ---------------------------------------- |
| 可见性问题（线程缓存不一致） | volatile、synchronized、原子类           |
| 指令重排导致的逻辑错误       | 内存屏障 + happens-before 规则           |
| 原子性问题（如 ++ 操作中断） | synchronized、Atomic* 类提供原子操作支持 |

**🧠 JMM 是什么样的“模型”？**

- **并不直接对应某个平台的硬件或 CPU 实现**；
- 而是 Java 语言对**多线程行为的抽象规范**；
- JVM 实现者必须按照 JMM 在不同平台上去**插入合适的内存屏障/同步策略**来“弥补”底层差异；
- 从而让程序员可以“写一次并发代码，到处安全运行”。

## **JMM 定义的八种操作**

JMM 定义了线程与主内存之间的交互操作（Java 指令层面）：

1. lock：作用于主内存变量，把变量标识为线程独占状态。
2. unlock：释放锁，使变量可以被其他线程访问。
3. read：从主内存读取变量到工作内存。
4. load：把 read 到的值放入工作内存的变量副本中。
5. use：从工作内存使用变量。
6. assign：把值赋给工作内存的变量。
7. store：把工作内存的变量值传给主内存。
8. write：把 store 的值写入主内存变量。

## **JMM 的三大特性**

### **1.** 原子性

- JMM 保证基本数据类型的读取/写入是原子的（除了 long、double 的非 volatile 读写在 Java 5 之前可能不是原子的）。
- synchronized、Lock、volatile 提供更高级别的原子性。

### **2.** 可见性

- 一个线程修改了变量，能及时被其他线程看到。
- 关键字 volatile 保证了可见性。
- synchronized 也能通过内存屏障来实现可见性。

### **3.** 有序性

- 编译器和 CPU 会优化指令顺序。
- JMM 规定了**happens-before** 规则来约束这种乱序执行。

##  **happens-before 规则（重点）**

JMM 用 happens-before 关系来定义操作之间的顺序约束。如果一个操作 A happens-before B，那就说明 A 的结果对 B 可见，并且 A 的执行先于 B。

常见的 happens-before 规则：

| **规则名称**  | **描述**                                                     |
| ------------- | ------------------------------------------------------------ |
| 程序次序规则  | 单个线程内，按照代码顺序执行。                               |
| 锁规则        | 一个解锁操作 happens-before 之后对同一锁的加锁。             |
| volatile 规则 | 对 volatile 变量的写操作 happens-before 后续对它的读操作。   |
| 线程启动规则  | Thread.start() happens-before 该线程中的任何操作。           |
| 线程终止规则  | Thread.join() happens-before 主线程获取子线程的任何结果。    |
| 传递性        | A happens-before B，B happens-before C，则 A happens-before C。 |

## **关键字与 JMM 的关系**

### **volatile**

- 保证可见性
- 禁止指令重排序（有一定的**有序性保证**）
- **不保证原子性**

### **synchronized**

- 保证**原子性**
- 保证**可见性**（通过解锁时将工作内存刷新回主内存）
- 保证**有序性**

| **操作手段**  | **是否保证原子性** | **是否保证可见性**   | **是否禁止重排** | **是否推荐用于自增** |
| ------------- | ------------------ | -------------------- | ---------------- | -------------------- |
| volatile      | ❌ 否               | ✅ 是                 | ✅ 是（部分）     | ❌ 否                 |
| synchronized  | ✅ 是               | ✅ 是                 | ✅ 是             | ✅ 可行               |
| AtomicInteger | ✅ 是               | ✅ 是（借助内存语义） | ✅ 是             | ✅ 推荐               |

## 重点

1.假如我现在能够保证操作基础数据类型int count的临界区互斥（只能被一个锁操作或者多个锁临界区互斥），那即便是基础数据类型的int也不会有线程安全问题

2.假如我现在有多个锁都可以操作count（临界区不互斥），那么此时必须使用原子类，原子类内部通过cas来保证++操作的准确

3.假如我的锁内部就只干了count++这一件事，那连锁都不用加了，直接使用原子类就能保证并发安全



```java
class Worker implements Runnable {
    private volatile boolean running = true;

    public void run() {
        while (running) {
            // 执行任务
        }
    }

    public void stop() {
        running = false;
    }
}
```

4.如果我能保证只有stop方法才能操作running，即不会出现另一个start方法来并发操作running，那么上述写法自己定义一个volatile的布尔值变量是执行效率最高的，因为避免了原子类内部cas操作

5.如果现在还有一个start方法会操作把running置为true，并且可能会stop并发执行，这个时候就必须使用原子类型的布尔值才能保证线程安全

## 内存屏障

当然可以，我们来**深入理解一下 synchronized 为什么能保证可见性和有序性**，这背后其实是 JVM 在生成字节码时插入了**内存屏障（memory barrier）** 指令。

**🧠 二、synchronized 如何工作？**

synchronized 实现基于：

- **对象头中的 monitor（监视器锁）**
- **JVM 插入内存屏障指令（memory barrier）**

### **🚧 三、synchronized 的内存屏障分析（重点！）**

JVM 在 synchronized 的锁的获取和释放处，会插入以下两类屏障：

| **屏障位置**  | **插入指令**          | **作用**                                         |
| ------------- | --------------------- | ------------------------------------------------ |
| 加锁（enter） | LoadLoad、LoadStore   | 禁止锁前的读/写重排序到锁内部                    |
| 解锁（exit）  | StoreStore、StoreLoad | 保证锁内部写的结果对其他线程可见，有序刷新主内存 |

#### **📌 解释每种内存屏障含义：**

| **屏障指令** | **含义**                                                     |
| ------------ | ------------------------------------------------------------ |
| LoadLoad     | 保证后续读取不会被提前到屏障前                               |
| LoadStore    | 保证后续写入不会被提前到屏障前                               |
| StoreStore   | 保证前面的写不会被重排序到后面                               |
| StoreLoad    | 🚨 最强屏障，确保写操作对后续读线程立即可见（**写后读不能重排**） |

### **🔁 四、完整执行流程举例**

```java
synchronized (lock) {
    sharedVar = 100;
}
```

执行流程如下：

1. **加锁阶段**（enter monitor）：
   - 插入 LoadLoad / LoadStore 屏障，防止外部变量提前进入同步块
2. **执行写操作**：sharedVar = 100;
3. **释放锁阶段**（exit monitor）：
   - 插入 StoreStore / StoreLoad 屏障
   - 保证 sharedVar 的写入对其他线程是**立刻可见的**
   - 并阻止后续读提前执行

### **✅ 所以，为什么 synchronized 能保证可见性？**

- 因为 **解锁时的 StoreLoad 屏障** 强制：
  - 线程将工作内存中的修改**刷新到主内存**；
  - 后续其他线程 **获取同一把锁** 时，会**重新从主内存读取最新值**。

这就实现了可见性。

### **✅ 为什么 synchronized 能保证有序性？**

- 内存屏障禁止了关键位置的 **指令重排**；
- 加锁前的代码不能被重排到同步块里；
- 同步块内的代码不能被重排到外面；
- 这就确保了**线程间的执行顺序是可预测的**。

### **🧠 总结一句话：**

> synchronized 通过 JVM 插入的 **内存屏障指令**，在加锁和释放锁时，强制刷新变量到主内存、禁止指令重排，因此天然具有**可见性 + 有序性 + 原子性**。

✅ 你这个总结非常到位，可以说是**对 synchronized 在 JMM 语义下最本质的一句话总结之一**。



## 临界区不互斥

> **synchronized 在加锁时，会从主内存读取共享变量的最新值，解锁时会把修改写入主内存，从而保证可见性；其“互斥”特性保障了原子性。若临界区不互斥，则原子性和可见性都无法保证，从而导致线程安全问题。**

🔒 1. 加锁时（monitorenter）：

- 会**读取主存中的共享变量最新值**；
- 避免使用工作内存中的旧值；
- 保证当前线程**看到的是别人写入的最新值** → ✅ 可见性；

🔓 2. 解锁时（monitorexit）：

- 会**将当前线程对共享变量的修改刷新回主内存**；
- 保证其他线程下次加锁能读到最新值 → ✅ 可见性；

🤝 3. 锁的“互斥性”：

- 一次只能有一个线程持有锁执行同步代码；
- 保证了复合操作（如 i++）的不可打断性 → ✅ 原子性；



> **synchronized 是通过“互斥 + 内存屏障”一并解决了原子性、可见性和有序性问题，是并发编程中最可靠的同步机制之一。**