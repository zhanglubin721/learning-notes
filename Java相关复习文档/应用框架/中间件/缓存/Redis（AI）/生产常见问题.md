## **1) 全量扫描命令**

**反模式**

- 在大数据集上直接跑：KEYS *、SCAN 0 MATCH * COUNT 很大(误用)、FLUSHALL（误操作）等。



**为什么危险**

- KEYS 是 **O(N) 且阻塞主线程**，大库会卡住所有请求。
- 误用 SCAN 的超大 COUNT 也可能造成瞬时阻塞。
- 误删（FLUSHALL/FLUSHDB）不可逆，且会触发大量释放导致长阻塞（若未启用 lazyfree）。



**典型症状**

- P99/P999 延迟陡增，LATENCY DOCTOR 报告 “command keys”。
- 业务侧“雪崩式超时”。



**正确做法 / 替代方案**

- 用 **增量游标**：SCAN/HSCAN/SSCAN/ZSCAN + MATCH + **小 COUNT（如 200~1000）**。
- 批处理删除时使用 UNLINK（异步释放）代替 DEL。
- 管理性操作放在 **从库**/影子库上进行。
- 高危命令加白名单/ACL 控制；生产禁止 KEYS *。



**示例**

```
# 安全扫描（增量、可中断续跑）
SCAN 0 MATCH user:* COUNT 500

# 大批量删除 → 先找再异步删
SCAN 0 MATCH sess:* COUNT 500
UNLINK sess:uid:1 sess:uid:2 ...

# 观察阻塞来源
LATENCY DOCTOR
SLOWLOG GET 128
```





## **2) 大 Key / 大集合**

**反模式**

- 对超大对象一次性读取：HGETALL、SMEMBERS、ZRANGE 0 -1、LRANGE 0 -1 等。
- 一次性删除/过期超大 Key。



**为什么危险**

- 单条命令搬运/释放的数据过大 → **网络与 CPU + jemalloc 释放**阻塞。
- 复制链路一次性同步大对象，放大从库延迟。



**典型症状**

- 某些命令慢日志堆积；业务偶发长尾。
- INFO MEMORY 碎片率升高；AOF/RDB fork 期间内存峰值高。



**正确做法 / 替代方案**

- **分页/流式**：
  - Hash/Set/ZSet → HSCAN/SSCAN/ZSCAN，或 ZRANGEBYSCORE ... LIMIT；
  - List → LRANGE 小批量 + “分段 List” 设计。
- **拆分大 Key**：按业务维度/时间/哈希成片（如 user:123:part:0..N）。
- 删除/淘汰用 UNLINK，过期/淘汰开启 **lazyfree** 相关配置。
- 读热点的 TopN 用 **物化缓存**（周期刷新的小 Key）。



**示例**

```
# ZSet 分页（游标式，避免深偏移）
ZREVRANGE rank 0 99 WITHSCORES
ZREVRANGEBYSCORE rank (lastScore -inf WITHSCORES LIMIT 0 100

# 异步删除
UNLINK huge:set
```

**配置建议**

```
lazyfree-lazy-eviction yes
lazyfree-lazy-expire   yes
lazyfree-lazy-server-del yes
replica-lazy-flush yes
```





## **3) 不可控脚本（Lua）**

**反模式**

- 在脚本里做**长循环/全库遍历/大集合处理**；无幂等、无超时退避。
- 把复杂业务逻辑都塞进 EVAL，单次执行时间不可控。



**为什么危险**

- Redis 脚本是 **原子且单线程** 执行，长脚本会**阻塞所有请求**。
- 脚本出错重试可能产生 **副作用**（非幂等）。



**典型症状**

- LATENCY LATEST 显示 command=EVAL 长时间；客户端大量“超时但未失败”。
- 主线程忙，复制延迟扩大。



**正确做法 / 替代方案**

- **短脚本 + 小批量**：脚本只做“原子拼装/校验/少量读写”。
- 需要扫描/重写时：移到 **后台任务/应用侧批处理**，分批 + 断点续跑。
- 设计 **幂等**（业务流水号/去重键）以便安全重试。
- 脚本常用先 SCRIPT LOAD 再 EVALSHA，降低网络开销。
- 设置 lua-time-limit，必要时 SCRIPT KILL（注意：仅在脚本未写入时可杀）。



**配置建议**

```
lua-time-limit 5000   # ms，防长脚本
slowlog-log-slower-than 10000
slowlog-max-len 1024
```





## **4) 持久化误配**

**反模式**

- 盲目 appendfsync always 或默认 everysec 但 **磁盘能力不足**；
- AOF rewrite 阈值过低导致频繁重写/抖动；
- RDB 与业务高峰重叠，fork + COW 内存尖峰。



**为什么危险**

- fsync/重写与业务 IO 争抢 → 尾延迟暴涨。
- fork() + 写时复制在大内存/高写入下会引发**内存瞬时膨胀**。



**典型症状**

- LATEST_FORK_USECS 异常大；iowait 飙升；aof_rewrite_in_progress=1 时 P99 抖。
- 恢复时间慢、复制断连。



**正确做法 / 替代方案**

- AOF 推荐：appendfsync everysec，配 no-appendfsync-on-rewrite yes；
- 开启混合 AOF（RDB preamble）：aof-use-rdb-preamble yes；
- 调整 rewrite：

```
auto-aof-rewrite-min-size 128mb
auto-aof-rewrite-percentage 100~200
aof-rewrite-incremental-fsync yes
```

- 
- RDB：开启增量 fsync、把 BGSAVE 放到低峰窗口：

```
rdb-save-incremental-fsync yes
```

- 
- 大实例：优先 **分片/Cluster**，降低单机内存体量；或在 **从库** 上做快照。



**自查**

```
INFO persistence
INFO memory
INFO stats
```





## **5) 复制/哨兵误配**

**反模式**

- 未设置 min-replicas-to-write/min-replicas-max-lag；
- Sentinel 数量/拓扑不足，quorum 太小；Sentinel 与主机放同一机架/同 AZ；
- backlog 太小，轻微抖动就触发全量复制。



**为什么危险**

- 网络分区时主库仍对外写 → **脑裂后数据不一致**。
- 频繁全量 → 带宽打满、从库长时间 catch up 不上。



**典型症状**

- 故障时存在“双主”；复制断开重连后经常全量。
- master_link_down_since_seconds 频繁非 0；repl_backlog_size 明显不够。



**正确做法 / 替代方案**

- 打开**安全写**：

```
min-replicas-to-write 2
min-replicas-max-lag 10
```

- 
- backlog 适当放大（覆盖你们的抖动时延 + 带宽能力）：

```
repl-backlog-size 64mb~512mb
repl-timeout 60
```

- 
- Sentinel 至少 **3 台**、跨机架/跨 AZ，合理 quorum（通常 2/3）。
- 业务读写分离时，**读从需容忍延迟**（或关键路径禁读从）。



**自查**

```
INFO replication
SENTINEL SENTINELS <master-name>
SENTINEL MASTER <master-name>
```





## **6) Cluster 误用**

**反模式**

- 跨槽多 key：MSET/MULTI/EVAL 包含不同槽位的键；
- 客户端未实现 MOVED/ASK/TRYAGAIN 重定向与路由更新；
- 迁槽期间“重试风暴”（无退避的死循环重试）。



**为什么危险**

- 直接报 CROSSSLOT；
- 迁移/故障时**大量失败或风暴**，击穿集群。



**典型症状**

- 错误日志大量 CROSSSLOT / MOVED；
- 迁槽时 QPS 断崖，客户端 CPU 飙高。



**正确做法 / 替代方案**

- **Hash Tag 规范**：把多 key 业务统一到 {tag} 同槽：

  user:{42}:name、user:{42}:cart…

- 客户端实现：

  - 启动拉取 CLUSTER SLOTS 建路由表；
  - 收到 MOVED → 更新路由并重试；
  - 收到 ASK → 先 ASKING 再发本次命令（不更新路由）；
  - TRYAGAIN/CLUSTERDOWN → 指数退避；
  - **Pipeline** 按槽分桶发送。

  

- 运维：再均衡在低峰；分片前选好 Key 模式，减少跨槽需求。



**自查**

```
CLUSTER KEYSLOT user:{42}:cart
CLUSTER SLOTS
```





## **监控 & 预警清单（建议落地）**

- 延迟：LATENCY DOCTOR、客户端 P99/P999；
- 慢日志：SLOWLOG LEN/GET；
- 内存：used_memory、used_memory_rss、mem_fragmentation_ratio；
- 持久化：aof_current_size、aof_rewrite_in_progress、latest_fork_usec；
- 复制：connected_slaves、master_link_down_since_seconds、repl_backlog_active/size；
- 集群：cluster_state、cluster_slots_ok、moved/ask 次数；
- 磁盘：iowait、设备队列、fsync 时延。





## **面试速答模板（30 秒）**

- **扫描**：不要 KEYS，用 SCAN 增量；删除用 UNLINK。
- **大 Key**：分页/拆分/物化 TopN；lazyfree 避免阻塞。
- **Lua**：短、幂等、原子；lua-time-limit；重活放后台。
- **持久化**：AOF everysec + RDB preamble；rewrite 阈值合理；BGSAVE 放低峰。
- **复制/哨兵**：开 min-replicas-*；backlog 足够；Sentinel ≥3，跨机架。
- **Cluster**：同槽要求（hash tag）；客户端处理 MOVED/ASK，指数退避，pipeline 按槽分桶。