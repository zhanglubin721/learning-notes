# 主线程

```
┌───────────────────────────────────────────────────────────┐
│                       aeMain()/eventLoop                  │
│                 while (!server.shutdown_asap)             │
└───────────────────────────────────────────────────────────┘
                 │
                 ▼
      ┌───────────────────────┐
      │ 计算最近时间事件到期点    │  ← serverCron/定时任务的最近触发时间
      │ nextTimer = nearest();│
      └──────────┬────────────┘
                 │
                 │  若已有到期的时间事件 → 不阻塞轮询
                 │  timeout = (now >= nextTimer) ? 0 : (nextTimer - now)
                 ▼
      ┌───────────────────────┐
      │ 轮询I/O (epoll/kqueue) │  ← 等待可读/可写/关闭等文件事件
      │ n = poll(timeout)     │
      └──────────┬────────────┘
                 │
     ┌───────────┴─────────────────────────────────────┐
     │ n > 0：有I/O就绪                                  │
     │ （优先处理等待事件；可能处理多条命令/多个连接）         │
     └───────────┬─────────────────────────────────────┘
                 │
                 ▼
      ┌───────────────────────┐
      │ 处理就绪的文件事件       │  ← 读取命令→解析→执行→写回响应
      │ handleFileEvents()    │
      └──────────┬────────────┘
                 │
                 ▼
      ┌───────────────────────┐
      │ 处理时间事件切片         │  ← 每轮都会执行一部分，避免饿死
      │ processTimeEvents()   │     (serverCron/active-expire-cycle/
      └──────────┬────────────┘      复制心跳/统计/持久化调度等)
                 │
                 └─────► 回到 while 顶部，开始下一轮 ◄─────
```

- **优先级**：每一轮都是“先 I/O、后时间事件”。
- **不饿死**：即使 I/O 很忙，**每轮**在 I/O 之后都会跑一小片 serverCron 等时间事件。
- **无 I/O 就绪**：poll(timeout) 超时返回 0 时，立即执行时间事件（timeout 由“最近到期的定时器”决定，为 0 则不阻塞）。
- **公平性**：processTimeEvents() 内部也遵循“限时/限量”的切片策略，典型如 activeExpireCycle 的采样 + 时间片，避免长时间阻塞主线程。







好——下面给你一版**贴近源码语义**的 aeProcessEvents() 关键伪代码 + 一张“线性顺序”的 ASCII 流程图。重点体现：**超时计算 → I/O 轮询 → 先处理文件事件 → 再切片处理时间事件**。



------





## **伪代码（接近 Redis 源码结构，去掉平台细节）**

```c++
int aeProcessEvents(eventLoop, flags):
    processed = 0

    # 1) 计算 poll 超时时间
    if (flags & AE_TIME_EVENTS):
        now = mstime()
        te  = aeSearchNearestTimer(eventLoop)   # 最近到期的时间事件
        if te != NULL:
            if te->when <= now:
                timeout = 0                     # 已到期 → 不阻塞
            else:
                timeout = te->when - now        # 距离到期的剩余毫秒
        else:
            if (!(flags & AE_DONT_WAIT)):
                timeout = AE_SEMANTIC_INFTY     # 没有时间事件且允许阻塞
            else:
                timeout = 0
    else:
        timeout = (flags & AE_DONT_WAIT) ? 0 : AE_SEMANTIC_INFTY

    # 2) I/O 轮询（文件事件）
    if (flags & AE_FILE_EVENTS):
        n = aeApiPoll(eventLoop, timeout)       # epoll/kqueue/select...
        for each readyFileEvent in eventLoop:
            call readyFileEvent->proc(client, mask)
            processed += 1

    # 3) 时间事件（切片执行，避免饿死/长阻塞）
    if (flags & AE_TIME_EVENTS):
        now = mstime()
        # 软时间片：最多花费若干毫秒（由上层控制，例如 serverCron 的预算）
        timeLimitStart = now
        do:
            te = eventLoop->timeEventHead
            ranOne = 0
            while te != NULL:
                if te->when <= now:
                    next_when = te->timeProc(eventLoop, te->clientData)
                    processed += 1
                    if next_when == AE_NOMORE:
                        unlink te                  # 不再重复
                    else:
                        te->when = next_when       # 重新安排下次触发
                    ranOne = 1
                te = te->next
            now = mstime()
        while ranOne && (now - timeLimitStart) < TIME_SLICE_MS

    return processed
```

> 关键信念：

- > **优先 I/O**：每轮先处理就绪的 socket 读写。

- > **不饿死**：无论 I/O 多忙，**每轮**都会执行一小部分时间事件。

- > **“定时”是靠时间判断**：到期就执行；next_when 决定下次触发时间。

- > **时间片**：时间事件遵循软限时，避免一次性执行太多而阻塞主线程。





## **ASCII 流程图（线性顺序、强调“先 I/O 后时间”）**

```
┌────────────────────────────────────────────────────────────┐
│                    aeProcessEvents(loop, flags)            │
└────────────────────────────────────────────────────────────┘
                     │
                     ▼
     ┌───────────────────────────────┐
     │ 搜索最近到期的时间事件(te)        │
     │ 计算 poll 超时 timeout          │
     └───────────────┬───────────────┘
                     │
                     ▼
     ┌───────────────────────────────┐
     │ 轮询 I/O: aeApiPoll(timeout)   │  ← 有到期事件 → timeout=0
     └───────────────┬───────────────┘
                     │
           n>0? ─────┘
                     │ yes
                     ▼
     ┌───────────────────────────────┐
     │ 处理就绪文件事件（读/写/关闭）     │  ← 解析命令/执行/写回
     └───────────────┬───────────────┘
                     │
                     ▼
     ┌───────────────────────────────┐
     │ 处理时间事件（切片执行）          │
     │ while(now>=te.when && 未超时)  │
     │   执行 te.timeProc()           │
     │   若返回下次时间 → 重新安排       │
     │   否则删除该时间事件             │
     └───────────────┬───────────────┘
                     │
                     └─────► 返回 processed，下一轮循环
```



# 异步线程

- **主线程**：负责绝大多数核心逻辑，包括命令解析、执行、网络收发、定时任务（serverCron）。这是 Redis 高性能的关键点：**事件驱动 + 单线程避免锁竞争**。
- **后台异步线程（BIO）**：Redis 确实有几个后台线程，用来执行那些**耗时但不要求实时性的操作**，避免主线程阻塞。

这不是“多线程处理命令”，而是“主线程把大块活甩给后台线程，自己继续处理请求”。





## **BIO（Background I/O）机制**

Redis 在 bio.c 里定义了 **BIO（Background I/O）线程池**。默认有三个后台队列，每个队列对应一个专门线程：

1. **BIO_CLOSE_FILE**：关闭文件（比如大文件 RDB、AOF 关闭时，close(fd) 有可能阻塞）。
2. **BIO_AOF_FSYNC**：刷盘操作（fdatasync() 可能很慢），异步写 AOF。
3. **BIO_LAZY_FREE**：惰性释放内存（lazy free）。

每个 BIO 都有一个工作队列，主线程把任务放进去，后台线程负责执行。





## **惰性释放（lazy free）**

### **为什么需要？**

- Redis 释放大对象时可能非常慢：

  比如一个 Hash 里有百万个 field，删除时要逐个 free entry → 主线程卡住。

- 为了避免这种“删除一个 key 阻塞几百毫秒”的情况，Redis 提供了 **惰性释放**。



### **怎么做？**

主线程在删除 key 时，不是立即 free() 整个对象，而是把这个释放操作封装成一个任务，丢给 **BIO_LAZY_FREE 线程**：

- 主线程只需要把对象从字典摘掉，马上返回给客户端 → 快速。
- 后台线程慢慢把这些 entry free 掉。



### **配置项**

在 redis.conf 里有几类 lazy free 相关开关：

- lazyfree-lazy-eviction：键淘汰时是否异步释放。
- lazyfree-lazy-expire：键过期时是否异步释放。
- lazyfree-lazy-server-del：DEL/UNLINK、FLUSHDB/FLUSHALL 时是否异步释放。
- replica-lazy-flush：复制时，是否异步释放从库的 flush。

另外，Redis 提供了专门的 UNLINK 命令：和 DEL 功能一样，但一定走异步释放。



## **其他异步线程**

除了 BIO，Redis 后续版本还引入了一些**专用线程**：

- **IO 线程**（6.0 引入）：可选开启，用来并发处理 **网络读写**（尤其是写出大响应），但**命令执行仍然单线程**。
- **后台持久化子进程**：严格来说不是线程，而是 fork() 出来的子进程，用于生成 RDB、重写 AOF，避免阻塞主线程。





## **延迟与性能权衡**

- 没有 lazy free：删除大 key → 主线程阻塞，延迟骤增。
- 开启 lazy free：主线程很快返回，但后台线程慢慢回收内存。**内存释放可能滞后**，内存占用会一度偏高。

这就是 Redis 的典型权衡：**延迟优先 vs 内存实时回收**。



## **面试常考点**

1. **Redis 是单线程的吗？**

   → 核心命令执行是单线程；后台有 BIO 线程（close/fsync/lazyfree）+ IO 线程（可选）+ 持久化子进程。

2. **UNLINK 和 DEL 的区别？**

   → DEL：主线程立即释放；UNLINK：异步释放，减少阻塞。

3. **lazyfree 适合什么场景？**

   → 删除/过期的大对象（Hash/Set/ZSet 列表很长时），能显著降低延迟峰值。