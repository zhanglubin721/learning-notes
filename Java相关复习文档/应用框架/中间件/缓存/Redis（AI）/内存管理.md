# 明确分工

## **1. Redis 自身的角色**

- Redis 不会自己实现复杂的“内存池/堆管理算法”。
- Redis 层面只关心：
  - **对象分配**：比如创建 SDS、dict、skiplist 节点，需要一段连续内存，就向 jemalloc 申请。
  - **对象释放**：比如 key 删除，调用 free() 把那块内存交还给 jemalloc。
  - **统计指标**：Redis 会维护 used_memory（逻辑占用）、并通过 jemalloc 的 API 或系统接口拿到 rss。

换句话说，Redis 自己只做 “我要一块”“我用掉了”“我不用了”的层级。



## **2. jemalloc 的角色**

- **真正的内存分配器**：负责把操作系统提供的大块虚拟内存（通过 mmap 等）拆分、分配、回收。

- **内部机制**：

  - **大小类对齐（size class）**：按 8B、16B、32B… 划分。申请 33B 也会拿 64B，造成内部碎片。
  - **arena**：多个 arena，避免多线程场景下锁竞争。
  - **延迟释放**：释放的内存块并不一定马上归还 OS，而是留在 arena 里，下次分配重用。

  

- **碎片处理**：jemalloc 会尝试合并、重用 free block，但它不能像 GC 一样“移动对象”，所以内存碎片无法彻底消除。





## **3. 碎片率与统计**

- **Redis 自己的指标**：

  - used_memory：逻辑分配（Redis 层统计的总字节数）。
  - used_memory_rss：jemalloc/OS 实际保留的物理内存。

  

- **mem_fragmentation_ratio = rss / used_memory**

  - ≈1 → 很健康。
  - ≫1 → jemalloc 内部空洞多，或 OS page 没归还。

  





## **4. 延迟相关**

- **删除大 key**：调用 free() 释放大量 jemalloc 块 → 主线程阻塞。
- **lazy free**：Redis 把释放操作扔到后台 BIO 线程，让 jemalloc 异步回收。
- **jemalloc 自己的延迟**：当 arena 扩展/收缩、与 OS 交互时，也可能引发短时卡顿。



✅ 总结：

Redis 的内存管理本质上就是**依赖 jemalloc**。Redis 只负责 **申请 / 释放 / 统计**，具体的 **空间分配、碎片处理、是否归还 OS** 都是 jemalloc 管的。你看到的“内存碎片率高”其实就是 **Redis 的逻辑内存需求 vs jemalloc/OS 实际分配**之间的差异。



# jemalloc 如何处理内存碎片



jemalloc 的“解决碎片问题”的思路不是像 GC 一样移动对象去整理，而是通过**分级分配、隔离管理、延迟回收与后台合并**来降低碎片风险。它的设计目标是：



- 在高并发下依然快速分配/释放；
- 尽量把碎片限制在可控范围；
- 在后台逐步回收大块空闲内存。





下面分层展开：



## **1. 大小类（size class）**

- jemalloc 把内存需求分成很多**离散的大小类别**（bin），例如：8B、16B、32B、48B、64B…
- 每个申请会被向上取整到某个 class，对齐分配。
- 好处：避免频繁的分裂/合并，分配/释放直接映射到固定 class 的空闲块。
- 问题：33B 也会拿到 48B（内部碎片不可避免），但通过细粒度划分，把浪费限制在较小比例。





## **2. Arena（多堆区）**

- jemalloc 会创建多个 **arena**（默认和 CPU 核心数相关）。
- 每个线程优先使用自己绑定的 arena，从而减少锁竞争。
- 不同 arena 独立管理内存 → 避免全局碎片集中。





## **3. Slab / Run 机制**

- 小对象在 arena 里由 **slab（运行 run）** 管理。
- 一个 slab 是一块大内存，里面切分成若干固定大小的对象单元。
- 分配时直接拿空位，释放时标记空闲。
- 这样避免了“通用堆分配器”的外部碎片问题。





## **4. 延迟回收与后台合并**

- jemalloc 释放内存时，一般只是把块放回对应的 bin/slab，不会马上归还操作系统。
- 如果 slab 整块空了，可以合并到 arena 的空闲列表；
- 如果 arena 内有大块空闲，jemalloc 可能调用 munmap() 或 MADV_DONTNEED 归还给 OS。
- Redis 常见的“RSS > used_memory”就是因为 jemalloc 暂时没有把空闲页还给 OS。





## **5. 碎片控制策略**

- **多 bin 精细化**：减少因对齐浪费导致的内部碎片。
- **arena 隔离**：降低多线程争用时的碎片膨胀。
- **后台清理**：jemalloc 内部有 decay 机制（衰减计数），会在一段时间后逐步归还空闲页。
- **可调参数**：通过 mallctl 可以调整 decay 时间、arena 数量、dirty page 回收策略。





## **6. 对 Redis 的影响**

- Redis 本身不做碎片整理，完全依赖 jemalloc。
- 如果你的业务产生大量小对象反复增删 → 碎片率会升高。
- Redis 提供 MEMORY PURGE 命令，触发 jemalloc 主动清理空闲页。
- INFO MEMORY 里的 fragmentation_ratio 可以观察 jemalloc 的碎片情况。





✅ 总结一句话：

jemalloc 解决内存碎片的手段是 **“预先分级 + slab 隔离 + arena 并行 + 延迟归还”**，核心思想是**控制和延缓碎片**，而不是彻底消除碎片（因为它不能像 GC 一样移动对象）。



```
[ Redis 申请内存 malloc(size) ]
                 │
                 ▼
        ┌───────────────────┐
        │  jemalloc 入口     │
        │  (size 向上取整)    │  ← 依据 size 选择路径
        └───────┬───────────┘
                │
     ┌──────────┴───────────┐
     │                      │
     │ size ≤ small/large?  │
     │                      │
     ▼                      ▼
[小/中对象路径]         [大对象路径]
(走 bin/slab)           (直走大块，页粒度)
     │                      │
     │                      │
     │                      ├──────────────► 如果无合适空闲大块
     │                      │                 → 向 OS 申请新映射 (mmap)
     │                      │
     │                      └─► 返回指针 (对齐到页/增量)
     │
     │  线程绑定/哈希挑选 arena（减少锁竞争）
     ▼
┌──────────────────────────────┐
│        选定 arena_N        	  │
│  (每个 arena 独立管理堆空间)    │
└──────────────────────────────┘
                 │
                 ▼
        ┌─────────────────┐
        │  选择 bin（大小类）│  ← 例如 8B/16B/32B/.../512B/...
        └───────┬─────────┘
                │
                ▼
   ┌──────────────────────────┐
   │   bin 里找可用的 slab   	 │
   │  (也叫 run：一大块内存)   	 │
   └───────┬──────────────────┘
           │ 有空位？     │ 没空位？
           ▼              ▼
┌────────────────┐   ┌──────────────────────────┐
│ 从 slab 拿一格  │   │ 申请/复用新的 slab(run)    │
│ (固定大小小块)   │   │  并挂到该 bin 的可用链表    │
└───────┬────────┘   └───────────┬──────────────┘
        │                        │
        ▼                        ▼
  [ 返回给 Redis 指针 ]      [ 再从新 slab 拿一格 ]
        │
        ▼
  ──▶ Redis 使用中 ◀──
        │
        │ free(ptr) 归还
        ▼
┌──────────────────────────────┐
│ 归还到所属 bin 的 slab 空位     │
│ (仅标记空闲，通常不立即还 OS)    │
└───────────┬──────────────────┘
            │ slab 全空？
            ▼
   ┌──────────────────────────┐
   │ slab 标记为完全空闲         │
   │ → arena 可将整块收拢       │
   │ → 触发 decay/背景回收      │
   └───────────┬──────────────┘
               │
               ▼
     [ 可能 MADV_DONTNEED / munmap 归还 OS ]
```





## **碎片“可能出现”的位置（★ 标注点）**

- **★ 大小类对齐（内部碎片）**：例如申请 33B，落到 48B class，浪费 15B。
- **★ slab 内洞（外部碎片）**：同一 slab 中小块交替分配/释放，形成零散空位；但因为是固定块大小，影响有限。
- **★ arena 间碎片**：不同线程/arena 的生命周期差异导致某些 arena 长期持有难以整合的空闲页。
- **★ 大对象回收滞后**：大块未及时 munmap，RSS 层面看起来“内存没降”。





## **回收与抑制碎片的路径**

- **bin/slab 层复用**：小块 free 后优先在**原 slab**复用，降低外部碎片。
- **slab 整块回收**：当一个 slab 全空 → 可从 bin 脱链，交给 arena 合并。
- **arena 衰减/清理**：jemalloc 的 **decay** 策略在一段时间后把空闲页 MADV_DONTNEED 或 munmap 归还 OS。
- **手动触发**：Redis 支持 MEMORY PURGE 主动让 jemalloc 清理空闲页。





## **你需要记住的三句话**

1. **分级分配（bin/slab）**把“小对象”碎片控制在固定大小块里；
2. **多 arena 隔离**减少竞争，但可能形成“跨 arena”层面的碎片；
3. **延迟归还（decay）与手动 PURGE**共同决定 RSS 何时下降；碎片率 = rss / used_memory。

如果你想，我可以再给一张“小对象 vs 大对象两条路径”的更精简版速记图，放到你的笔记里当索引页。





# jemalloc 内存管理

**jemalloc 的三大核心概念：arena、bin、slab** 分开讲清楚。你可以把它们想象成三层：

- **arena（场馆）**：大舞台，多个线程各自在不同 arena 上演，减少争抢。
- **bin（分区/桶）**：舞台里专门划出的“分类区”，按照分配大小分区。
- **slab（或 run，运行块）**：每个 bin 下的具体存储区，把内存切割成一格格小单元。





## **1. Arena（堆区）**

- **定义**：jemalloc 管理的内存空间被分成多个 arena，每个 arena 是一套独立的内存分配子系统。

- **目的**：解决多线程并发时的锁竞争问题。

  - 如果只有一个全局堆，多个线程同时 malloc/free 都要抢锁，性能差。
  - 有多个 arena 后，不同线程各用不同的 arena，彼此独立，锁冲突少。

  

- **特点**：

  - 默认 arena 数量和 CPU 核心数相近（可调）。
  - 每个 arena 内部有自己的 bin/slab 管理体系。
  - 线程通常绑定到一个 arena（thread-local），除非 arena 数不够才会共享。

  





## **2. Bin（大小类）**

- **定义**：每个 arena 内部把内存需求按大小分区（bin），即**不同的 size class**。

- **目的**：减少内部碎片，提高分配速度。

- **例子**（常见 size class）：

  - 8B, 16B, 32B, 48B, 64B, … 直到 512B（小对象）
  - 更大的有 middle/large class，通常按 2 的倍数或固定步长对齐。

  

- **分配策略**：

  - 申请 33B → 向上取整到 48B → 分配自 48B bin。

  

- **效果**：

  - 申请/释放非常快：直接在对应 bin 里拿空位。
  - 内部碎片可控：浪费最多 < (下个 class - 实际大小)。

  





## **3. Slab（或 Run）**

- **定义**：bin 里的实际存储单位。jemalloc 会向 OS 申请大块内存（通常是一页或多页，例如 4KB~几百 KB），把它切成很多等大小的小格子，用来放置对象。

- **过程**：

  - 当 bin 里没有可用格子时，就新建一个 slab。
  - 一个 slab 只服务于一个 bin（固定大小类）。

  

- **管理方式**：

  - 每个 slab 维护一个空闲链表，分配时直接取一个空格子。
  - 释放时把格子归还，标记空闲。
  - 当 slab 全部空闲 → 可以归还给 arena，再可能被 jemalloc 合并、甚至通过 madvise/munmap 归还给操作系统。

  

- **优点**：

  - 避免外部碎片：同一个 slab 全是固定大小的格子，不会因为不同大小对象混用而产生零散空洞。

  





## **4. 三者关系**

你可以把 jemalloc 的分配逻辑理解成：

```
Redis malloc(size)
   │
   ▼
Arena (线程所属的堆区)
   │
   ▼
Bin (选择合适的大小类)
   │
   ▼
Slab (该 bin 下的运行块)
   │
   └─> 拿到一个小格子 (指针返回给 Redis)
```

- **Arena**：多线程隔离，减少锁竞争。
- **Bin**：分大小类，控制内部碎片。
- **Slab**：把一大块切小格子，快速分配/释放，避免外部碎片。





## **5. 碎片控制点**

- **内部碎片**：申请 33B → 实际占 48B；这是 bin 大小粒度决定的。
- **外部碎片**：slab 内格子分配/释放无序时也可能有空洞，但仍然是固定大小块，不影响可重用性。
- **跨 arena 碎片**：线程生命周期不同，某些 arena 长期持有难以整合的空闲页 → 形成全局碎片。