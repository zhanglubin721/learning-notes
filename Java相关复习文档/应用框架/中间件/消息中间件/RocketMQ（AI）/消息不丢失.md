# **0. 威胁模型（沿消息路径逐段看丢失点）**

| **环节**             | **可能丢失点**                         | **保护思路（要点）**                                         |
| -------------------- | -------------------------------------- | ------------------------------------------------------------ |
| Producer→Broker 发送 | 发送超时/网络抖动/路由失效             | **同步发送** + **失败重试** + **故障规避选队列**，收到 Broker 的**存储成功**类确认才算成功 |
| Broker 写入本机      | 仅写入 PageCache 未落盘时宕机          | **同步刷盘 (SYNC_FLUSH)**，确认刷到磁盘后再回 ACK            |
| Broker 侧副本        | Master 落盘后宕机，且无副本/副本未追上 | **同步复制 ACK**（传统 SYNC_MASTER）或 **DLedger/Raft 多副本多数派提交** |
| 消费端处理           | 拉到消息但进程崩溃/ACK 提交前失败      | **成功后再提交位点**（Push/LitePull）或 **POP 场景 ack 成功**，失败进入 **重试/死信**，配合**业务幂等** |





# **1. 发送侧：让“成功返回”代表“已可靠存储”**

**目标**：只有当**服务端已可靠持久化（最好已多副本提交）**时 Producer 才“成功”。

- **使用同步发送**

  - DefaultMQProducer.send(msg)（同步）优先；异步发送要关注回调失败重试逻辑。

  

- **打开失败重试与故障规避**

  - 关键参数（Producer）：

    - sendMsgTimeout（适度拉长，防止慢盘/复制抖动误判）
    - retryTimesWhenSendFailed（同步重试次数）
    - retryTimesWhenSendAsyncFailed（异步重试次数）
    - retryAnotherBrokerWhenNotStoreOK=true（存储返回“非 OK”时，自动换 Broker 再试）
    - **延迟容错**（默认开启）：避开近期慢/失败队列（LatencyFaultTolerance）

    

  

- **识别“非可靠”返回并当作失败处理**

  - SendStatus 里如 FLUSH_DISK_TIMEOUT、FLUSH_SLAVE_TIMEOUT、SLAVE_NOT_AVAILABLE → **当失败对待并重试其他 Broker**（结合上面参数）。
  - 切忌把 SEND_OK 以外的状态当作成功。

  

> 小结：**同步发送 + 合理超时 + 存储非 OK 视为失败 + 故障规避**，保证“发成功≈已经可靠写入或将被重试”。







# **2. Broker 存储侧：把“写入”变成“可靠持久化”**

## **2.1 磁盘持久化（单机不丢）**

- **同步刷盘**（关键）：flushDiskType=SYNC_FLUSH

  - 发送路径在**消息真正刷到磁盘**后才返回。避免“只在 PageCache 尚未来得及落盘就掉电/宕机”的丢失窗口。
  - 异步刷盘 (ASYNC_FLUSH) 性能高但有风险：宕机可能丢失最后一段消息。

  

- **页缓存/commit 缓冲**

  - transientStorePoolEnable=true 可提升性能，但仍需 SYNC_FLUSH 才谈“可靠落盘”确认。

  

- **写入失败保护/流控**

  - 磁盘水位、PageCache 忙时会“拒绝写入”而不是吞掉（Producer 侧拿到失败结果→重试其它队列）。

  





## **2.2 副本复制（机器级不丢）**

两条主流路线，选其一即可：

- **传统主从：同步复制（强烈推荐）**

  - brokerRole=SYNC_MASTER（Master 等待 Slave ACK）
  - Producer 收到的成功**代表 Master 落盘 + Slave 也已复制（通常也落盘）**；Master 宕机可切换 Slave 读。
  - 仍需 flushDiskType=SYNC_FLUSH 才能避免“Master 仅写 Cache 未落盘”的风险。

  

- **DLedger/Raft 多副本（5.x/4.x DLedger）**

  - 多节点组成复制组，**多数派提交**后才“可见/成功”。
  - Leader 崩溃可自动选主；与 SYNC_FLUSH 搭配可实现**多数派落盘**后返回（最稳）。

  

> 小结：**单机 SYNC_FLUSH 解决“掉电丢”，多副本（SYNC_MASTER 或 DLedger 多数派）解决“单机损毁丢”。**







# **3. 消费侧：不丢 = 不要“先提交后处理”**

## **3.1 Push / LitePull（有队列位点）**

- **先处理，后提交位点**

  - 业务处理成功（写 DB/外部系统成功）→ 再 commit / 返回 CONSUME_SUCCESS。
  - 失败：RECONSUME_LATER，进入 **重试队列 %RETRY%Group**；超过阈值进 **死信 %DLQ%Group**（人工/自动补偿）。

  

- **并发/批量**

  - 批量拉取/批量消费要确保**批内部分失败**能“分拆”回退或整批重试。

  

- **广播模式**

  - 位点多为本地，注意**进程重启**后的恢复策略，避免“读过但未处理成功”。

  





## **3.2 POP（可见性超时 + ACK，无位点）**

- **收到消息 ≠ 成功**：必须 ACK 成功才算消费成功。
- **可见性超时**过短会导致“重复”（未完成就超时被重投），过长会导致“失败恢复慢”。
- 失败或超时：消息被 Revive 服务重新投递，最终进 **popRetry/死信**；**不丢但可能重复**。





## **3.3 幂等是兜底**

- “至少一次”意味着**可能重复**：对外系统写入必须以**业务主键/去重表/唯一索引**保证幂等。
- **不要**依赖 MessageId 做幂等主键（跨集群不唯一）；用**业务 Key（UNIQ_KEY/自定义 Key）+ 业务表约束**更稳。







# **4. 宕机恢复 & 运行时保护**

- **Broker 启动恢复**

  - 以 CommitLog 为权威，**重放**构建/修复 ConsumeQueue、Index；尾部不完整记录会被丢弃（这正是为什么必须 SYNC_FLUSH 才能保证不丢）。

  

- **删除/清理策略**

  - 只删除**过期完整文件**（保留天数、磁盘占用阈值），不会删“正在使用的尾部”。

  

- **NameServer 与路由**

  - NameServer 掉了不影响已知路由（有缓存），不会导致消息丢失；它不存消息。

  

- **磁盘水位保护**

  - 达阈值会拒写并返回错误 → Producer 感知并切换/限流，避免“写入失败却悄悄吞掉”。

  







# **5. 一套“几乎不丢”的推荐配置/实践**

## **5.1 Broker（broker.conf关键项）**



- flushDiskType=SYNC_FLUSH

- 复制策略二选一：

  - 传统：brokerRole=SYNC_MASTER（配从库）
  - 或 DLedger：部署多副本复制组（多数派提交），启用对应的 DLedger/Controller 配置

  

- 合理的清理阈值：deleteWhen=04、fileReservedTime、diskMaxUsedSpaceRatio

- 保护：开启拒写保护、保持足够 I/O 吞吐（NVMe、独占盘、XFS/EXT4、noatime）





## **5.2 Producer（Java）**

```
DefaultMQProducer p = new DefaultMQProducer("p_group");
p.setSendMsgTimeout(10000);                 // 视磁盘/复制时延拉长
p.setRetryTimesWhenSendFailed(3);
p.setRetryTimesWhenSendAsyncFailed(3);
p.setRetryAnotherBrokerWhenNotStoreOK(true);// 非OK视为失败并切换
p.start();
// 业务：优先同步发送，检查 SendStatus，只把 SEND_OK 当成功
```



## **5.3 Consumer（Java，Push 模型）**

```
DefaultMQPushConsumer c = new DefaultMQPushConsumer("c_group");
c.setConsumeMessageBatchMaxSize(1); // 批量时注意失败回退策略
c.registerMessageListener((msgs, ctx) -> {
    for (MessageExt m : msgs) {
        if (processBusiness(m)) {   // 业务幂等落库/外部调用成功
            continue;
        } else {
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; // 成功后再确认
});
c.start();
```



## **5.4 POP（Java，示意）**

- 业务成功后 ack(receiptHandle)；失败不 ack 让其回投或手动送重试；合理设 invisibilityTimeout。







# **6. 常见误区 & 面试快问快答**

- **“RocketMQ 能做到 Exactly-Once 吗？”**

  - **不保证**。官方是 at-least-once。端到端“几乎不丢 + 幂等落地”是正确姿势。

  

- **“同步刷盘够了吗？”**

  - 只能防“单机掉电丢”。要防“机器损坏/磁盘坏块/主机不可达”，还需**同步复制或 DLedger 多副本**。

  

- **“拿 MessageId 做幂等主键”**

  - 不要。它是物理定位 ID，跨集群不唯一；**用业务 Key + 唯一约束**。

  

- **“Push 是服务端主动推？”**

  - 不是。**客户端长轮询拉取**。位点提交一定要在业务成功之后。

  

- **“重试/死信会丢吗？”**

  - 不丢，但会重复、会延迟。死信需要人工/任务恢复再消费。

  







# **7. 最小代价达到“几乎不丢”的组合**

1. **Producer：**同步发送 + 存储非 OK 视为失败 + 重试 + 故障规避
2. **Broker：**SYNC_FLUSH + （**SYNC_MASTER** 或 **DLedger 多数派**）
3. **Consumer：****成功后再提交位点/ack** + 失败走重试/死信 + **业务幂等**
4. **运维：**监控刷盘/复制时延、磁盘水位、堆积与重试量，异常即告警