# 计算机基础知识复习计划

## 计算机必备知识

- [x] 中央处理单元 CPU
- [x] CPU 是如何执行代码

## 算法复杂度 / Big-O / 渐进分析法

- [ ] Harvard CS50 —— 渐进表示

- [ ] Big O 记号（通用快速教程）

- [ ] Big O 记号（以及 Omega 和 Theta）

- [ ] Skiena 算法

- [ ] 对于算法复杂度分析的一次详细介绍

- [ ] 增长阶数（Orders of Growth）

- [ ] 渐进性（Asymptotics）

- [ ] UC Berkeley Big O

- [ ] UC Berkeley Big Omega

- [ ] 平摊分析法（Amortized Analysis）

  举证“Big O”

  - [ ] ​	TopCoder（包括递归关系和主定理）：
  - [ ] ​	速查表（Cheat sheet）

## 数据结构

### 数组（Arrays）

- [ ] 各种数组的基本介绍
- [ ] 各种数组的基础方法
- [ ] 数组的扩容
- [ ] 时间复杂度
  - 在数组末端增加/删除、定位、更新元素，只允许占 O(1) 的时间复杂度（平摊（amortized）去分配内存以获取更多空间）
  - 在数组任何地方插入/移除元素，只允许 O(n) 的时间复杂度
- [ ] 空间复杂度
  - 因为在内存中分配的空间邻近，所以有助于提高性能
  - 空间需求 = （大于或等于 n 的数组容积）* 元素的大小。即便空间需求为 2n，其空间复杂度仍然是 O(n)

### 链表（Linked Lists）

- [ ] 各种数组的基本介绍
- [ ] 各种数组的基础方法
- [ ] 为什么你需要避免使用链表
- [ ]  链表 vs 数组

### 堆栈（Stack）

- [ ] 堆栈的基本介绍
- [ ] 使用堆栈  先进后出（可以不实现，意义不大）

### 队列（Queue）

- [ ] 使用队列 —— 先进先出
- [ ] 原型队列/先进先出（FIFO）
- [ ] 优先级队列
- [ ] 各种实现队列的方式以及开销

### 哈希表（Hash table）

- [ ] 各种哈希的使用与区别
- [ ] 哈希表原理

### 树（Trees）

- [ ] 基本树形结构
- [ ] 操作、遍历算法
- [ ] BFS与DFS
- [ ] 二叉树的遍历 BSTs

### 堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）

- [ ] 基本内容

### 图（Graphs）

图论能解决计算机科学里的很多问题

- [ ] 有向图（directed）
- [ ] 无向图（undirected）
- [ ] 邻接矩阵（adjacency matrix）
- [ ] 邻接表（adjacency list）
- [ ] 遍历：广度优先(BFS), 深度优先(DFS)

熟悉以上每一种图的表示法，并了解各自的优缺点

知道两种遍历方法它们的计算复杂度和设计上的权衡以及如何用代码实现它们

（遇到一个问题时，首先尝试基于图的解决方案，如果没有再去尝试其他的）

## 更多知识

### 二分查找

### 位运算

### 递归、回溯

### 动态规划

### 面向对象编程

- [ ] 面向对象编程原则

### 设计模式

主要有如下的设计模式:

- [ ] 策略模式（strategy）
- [ ] 单例模式（singleton）
- [ ] 适配器模式（adapter）
- [ ] 原型模式（prototype）
- [ ] 装饰器模式（decorator）
- [ ] 访问者模式（visitor）
- [ ] 工厂模式，抽象工厂模式（factory, abstract factory）
- [ ] 外观模式（facade）
- [ ] 观察者模式（observer）
- [ ] 代理模式（proxy）
- [ ] 委托模式（delegate）
- [ ] 命令模式（command）
- [ ] 状态模式（state）
- [ ] 备忘录模式（memento）
- [ ] 迭代器模式（iterator）
- [ ] 组合模式（composite）
- [ ] 享元模式（flyweight）

### 组合（Combinatorics） (n 中选 k 个) & 概率（Probability）

### NP, NP-完全和近似算法

- [ ] 知道 NP 完全是什么意思.
- [ ] 计算复杂度（视频）

### 缓存（Cache）

- [ ]  LRU 缓存
- [ ]  CPU 缓存

### 进程（Processe）和线程（Thread）

进程、线程、协程

- [ ] 进程和线程的区别
- [ ] 进程
- [ ] 线程
- [ ] 锁
- [ ] 互斥
- [ ] 信号量
- [ ] 监控
- [ ] 他们是如何工作的
- [ ] 死锁
- [ ] 活锁



- [ ] CPU 活动, 中断, 上下文切换
- [ ] 现代多核处理器的并发式结构
- [ ] 分页（paging），分段（segmentation）和虚拟内存（视频）
- [ ] 中断
- [ ] 进程资源需要（内存：代码、静态存储器、栈、堆、文件描述符、I/O）
- [ ] 线程资源需要（在同一个进程内和其他线程共享以上（除了栈）的资源，但是每个线程都有独立的程序计数器、栈计数器、寄存器和栈）
- [ ] Fork 操作是真正的写时复制（只读），直到新的进程写到内存中，才会生成一份新的拷贝。
- [ ] 操作系统和底层硬件是如何初始化上下文切换的？

### 调度

- [ ] 在操作系统中是如何运作的

### 浮点数

- [ ] 浮点数的计算原理与错误

### Unicode

### 网络知识

- [ ] UDP 和 TCP：网络传输协议中的数据压缩
- [ ] TCP/IP 和 OSI 模型解释 
- [ ] 互联网上的数据包传输。网络和 TCP/IP 教程
- [ ] HTTP
- [ ] SSL 和 HTTPS
- [ ] SSL/TLS
- [ ] HTTP 2.0（视频）
- [ ] 套接字（Sockets）

## 额外知识

### 编译器

### 密码学

### 并行编程

### 快速傅里叶变换

### 布隆过滤器

### 分治算法

### 平衡查找树

- [ ] 伸展树
- [ ] 红黑树
- [ ] B 树

### 跳表

### 线性规划（Linear Programming）

- [ ] 线性规划
- [ ] 寻找最小成本
- [ ] 寻找最大值

### 离散数学