# 多线程编程

## 创建新线程的四种方式



## callable与FutureTask配合使用

```Java
public class ThreadTest {

    static class WaiMai{}

    static class DianWaiMai implements Callable<Boolean>{
        private WaiMai waimai;

        DianWaiMai(WaiMai waimai){
            this.waimai = waimai;
        }

        @Override
        public Boolean call() throws Exception {
            long waitTime = waimai.hashCode() % 5000;
            Thread.sleep(waitTime);
            return (System.currentTimeMillis() & 1) == 1;
        }
    }
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService threadPool = Executors.newFixedThreadPool(2);
        DianWaiMai dianWaiMai = new DianWaiMai(new WaiMai());
        FutureTask<Boolean> futureTask = new FutureTask((Callable) dianWaiMai);

        System.out.println(System.currentTimeMillis() + " 下单外卖，并且去运动");
        threadPool.execute(futureTask);

        Thread.sleep(2000);
        System.out.println(System.currentTimeMillis() + " 运动结束,看看外卖到了没");

        if (!futureTask.isDone()) {
            System.out.println(System.currentTimeMillis() + " 外卖还没到,在等等吧");
            Thread.sleep(1000);
            if (!futureTask.isDone()) {
                System.out.println(System.currentTimeMillis() + " 妈的外卖还没到,取消，吃食堂去");
                futureTask.cancel(false);
            }
        }
        if (!futureTask.isCancelled()) {
            Boolean res = futureTask.get();
            System.out.println(System.currentTimeMillis() + " 外卖到了");
            if (res) {
                System.out.println("太多了吃撑了");
            } else {
                System.out.println("太少了，不够吃，再去食堂吃一点");
            }
        }
        threadPool.shutdown();
    }
}
```

拿去一跑，一切明了，skr skr~

如果想看懂上面代码的全部细节你还需要了解

```Java
//创建线程池
//可以往线程池放n个任务，但每次执行只执行3个任务，别的任务在排队
ExecutorService threadPool = Executors.newFixedThreadPool(3);
//缓存的线程池，有几个任务几个线程，动态变化
ExecutorService threadPool = Executors.newCachedThreadPool();
//单线程，线程池只有一个线程
ExecutorService threadPool = Executors.newSingleThreadExecutor();


//FutureTask实现了Callbale和Runnable接口
//dianWaiMai是实现了Callable类的自定义线程类
FutureTask<String> futureTask = new FutureTask<>((Callable) dianWaiMai);

//直接启动线程
Thread thread = new Thread(futureTask);
thread.start();

//或者使用线程池启动线程
threadPool.execute(futureTask);

//获取运行状况
boolean done = futureTask.isDone();
boolean cancelled = futureTask.isCancelled();

//取消运行
futureTask.cancel(true);
//或者停止线程池的运行
threadPool.shutdown();
```

